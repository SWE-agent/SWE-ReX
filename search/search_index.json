{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SWE-ReX","text":"<p>SWE-ReX is a runtime for interacting with sandboxed shell environments, allowing to effortlessly let your AI agent run anything from <code>ls</code> to interactive <code>pdb</code> sessions. Whether commands are executed locally or remotely in docker containers, on AWS, modal, or something else, your code remains the same.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>Let's take a look how SWE-ReX works:</p> <ol> <li>Your central entry point is one of the <code>Deployment</code> classes, depending on where your code should run. </li> <li>Your <code>Deployment</code> instances allows your to start your docker container, AWS instance, or whatever at the push of a button. That's right, no more fiddeling with the AWS console!</li> <li>After the <code>Deployment</code> has started your container somewhere, you are handed a <code>RemoteRuntime</code> instance.   This is your main interface for interacting with the environment. You can use it start new shell or interactive sessions, read and write files, execute one-off commands, etc.</li> </ol> <p></p> <p>Looking closer at the internals:</p> <ol> <li> <p>Within the container, we have a fastapi Server that transfers all request from the <code>RemoteRuntime</code> to the <code>LocalRuntime</code>.    The <code>LocalRuntime</code> has the exact same interface as the <code>RemoteRuntime</code> class and it is what actually executes the commands.    In fact, if you want to run something locally (or your whole codebase runs in a sandboxed environment), you can just use the <code>LocalRuntime</code> directly!    Both classes are absolutely interchangeable, in fact we even transfer any exceptions happening in the <code>LocalRuntime</code> to the <code>RemoteRuntime</code> transparently,    so you can easily catch and ignore certain errors.</p> </li> <li> <p>The <code>Runtime</code> class provides several methods for reading/writing files, an <code>execute</code> method for running arbitrary commands, but the most important one is <code>run_in_session</code>.    This method allows you to run a command in an existing shell session (or an interactive tool running inside of it) and return the output.    In fact, you can have multiple sessions open at the same time, running different commands and tools in parallel!</p> </li> </ol>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Here's a simple example:</p> <pre><code>import asyncio\n\nfrom swerex.deployment.local import LocalDeployment\nfrom swerex.runtime.abstract import Action as A\nfrom swerex.runtime.abstract import (\n    CloseSessionRequest,\n    CreateSessionRequest,\n)\n\ndeployment = LocalDeployment()\nasyncio.run(deployment.start())\nr = deployment.runtime\n# fmt: off\nprint(r.is_alive())\nprint(r.create_session(CreateSessionRequest()))\nprint(r.run_in_session(A(command=\"doesnexist\",)))\nprint(r.run_in_session(A(command=\"ls\",)))\nprint(r.run_in_session(A(command=\"python\", is_interactive_command=True, expect=[\"&gt;&gt;&gt; \"])))\nprint(r.run_in_session(A(command=\"print('hello world')\", is_interactive_command=True, expect=[\"&gt;&gt;&gt; \"])))\nprint(r.run_in_session(A(command=\"quit()\\n\", is_interactive_quit=True)))\nprint(r.run_in_session(A(command=\"echo 'test'\",)))\nprint(r.run_in_session(A(command=\"echo 'answer'\",)))\nprint(r.run_in_session(A(command=\"doesnexist\",)))\nprint(r.close_session(CloseSessionRequest()))\n# fmt: on\n</code></pre>"},{"location":"api/server/","title":"Server","text":""},{"location":"api/server/#swerex.server","title":"swerex.server","text":""},{"location":"api/server/#swerex.server.AUTH_TOKEN","title":"AUTH_TOKEN  <code>module-attribute</code>","text":"<pre><code>AUTH_TOKEN = ''\n</code></pre>"},{"location":"api/server/#swerex.server.api_key_header","title":"api_key_header  <code>module-attribute</code>","text":"<pre><code>api_key_header = APIKeyHeader(name='X-API-Key')\n</code></pre>"},{"location":"api/server/#swerex.server.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate(request: Request, call_next)\n</code></pre> <p>Authenticate requests with an API key (if set).</p> Source code in <code>swerex/server.py</code> <pre><code>@app.middleware(\"http\")\nasync def authenticate(request: Request, call_next):\n    \"\"\"Authenticate requests with an API key (if set).\"\"\"\n    if AUTH_TOKEN:\n        api_key = await api_key_header(request)\n        if api_key != AUTH_TOKEN:\n            raise HTTPException(status_code=401, detail=\"Invalid API Key\")\n    return await call_next(request)\n</code></pre>"},{"location":"api/server/#swerex.server.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/close\")\nasync def close():\n    await runtime.close()\n    return CloseResponse()\n</code></pre>"},{"location":"api/server/#swerex.server.close_session","title":"close_session  <code>async</code>","text":"<pre><code>close_session(request: CloseSessionRequest)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/close_session\")\nasync def close_session(request: CloseSessionRequest):\n    return serialize_model(await runtime.close_session(request))\n</code></pre>"},{"location":"api/server/#swerex.server.create_session","title":"create_session  <code>async</code>","text":"<pre><code>create_session(request: CreateSessionRequest)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/create_session\")\nasync def create_session(request: CreateSessionRequest):\n    return serialize_model(await runtime.create_session(request))\n</code></pre>"},{"location":"api/server/#swerex.server.exception_handler","title":"exception_handler  <code>async</code>","text":"<pre><code>exception_handler(request: Request, exc: Exception)\n</code></pre> <p>We catch exceptions that are thrown by the runtime, serialize them to JSON and return them to the client so they can reraise them in their own code.</p> Source code in <code>swerex/server.py</code> <pre><code>@app.exception_handler(Exception)\nasync def exception_handler(request: Request, exc: Exception):\n    \"\"\"We catch exceptions that are thrown by the runtime, serialize them to JSON and\n    return them to the client so they can reraise them in their own code.\n    \"\"\"\n    if isinstance(exc, (HTTPException, StarletteHTTPException)):\n        return await http_exception_handler(request, exc)\n    _exc = _ExceptionTransfer(\n        message=str(exc), class_path=type(exc).__module__ + \".\" + type(exc).__name__, traceback=traceback.format_exc()\n    )\n    return JSONResponse(status_code=511, content={\"swerexception\": _exc.model_dump()})\n</code></pre>"},{"location":"api/server/#swerex.server.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(command: Command)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/execute\")\nasync def execute(command: Command):\n    return serialize_model(await runtime.execute(command))\n</code></pre>"},{"location":"api/server/#swerex.server.is_alive","title":"is_alive  <code>async</code>","text":"<pre><code>is_alive()\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.get(\"/is_alive\")\nasync def is_alive():\n    return serialize_model(await runtime.is_alive())\n</code></pre>"},{"location":"api/server/#swerex.server.read_file","title":"read_file  <code>async</code>","text":"<pre><code>read_file(request: ReadFileRequest)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/read_file\")\nasync def read_file(request: ReadFileRequest):\n    return serialize_model(await runtime.read_file(request))\n</code></pre>"},{"location":"api/server/#swerex.server.root","title":"root  <code>async</code>","text":"<pre><code>root()\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.get(\"/\")\nasync def root():\n    return {\"message\": \"hello world\"}\n</code></pre>"},{"location":"api/server/#swerex.server.run","title":"run  <code>async</code>","text":"<pre><code>run(action: Action)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/run_in_session\")\nasync def run(action: Action):\n    return serialize_model(await runtime.run_in_session(action))\n</code></pre>"},{"location":"api/server/#swerex.server.serialize_model","title":"serialize_model","text":"<pre><code>serialize_model(model)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>def serialize_model(model):\n    return model.model_dump() if hasattr(model, \"model_dump\") else model.dict()\n</code></pre>"},{"location":"api/server/#swerex.server.upload","title":"upload  <code>async</code>","text":"<pre><code>upload(file: UploadFile = File(...), target_path: str = Form(...), unzip: bool = Form(False))\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/upload\")\nasync def upload(\n    file: UploadFile = File(...),\n    target_path: str = Form(...),  # type: ignore\n    unzip: bool = Form(False),\n):\n    target_path: Path = Path(target_path)\n    target_path.parent.mkdir(parents=True, exist_ok=True)\n    # First save the file to a temporary directory and potentially unzip it.\n    with tempfile.TemporaryDirectory() as temp_dir:\n        file_path = Path(temp_dir) / target_path.name\n        try:\n            with open(file_path, \"wb\") as f:\n                f.write(await file.read())\n        finally:\n            await file.close()\n        if unzip:\n            with zipfile.ZipFile(file_path, \"r\") as zip_ref:\n                zip_ref.extractall(target_path)\n        else:\n            shutil.copy(file_path, target_path)\n    return UploadResponse()\n</code></pre>"},{"location":"api/server/#swerex.server.write_file","title":"write_file  <code>async</code>","text":"<pre><code>write_file(request: WriteFileRequest)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/write_file\")\nasync def write_file(request: WriteFileRequest):\n    return serialize_model(await runtime.write_file(request))\n</code></pre>"},{"location":"api/deployments/abstract/","title":"Abstract","text":""},{"location":"api/deployments/abstract/#swerex.deployment.abstract.AbstractDeployment","title":"swerex.deployment.abstract.AbstractDeployment","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"api/deployments/abstract/#swerex.deployment.abstract.AbstractDeployment.runtime","title":"runtime  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>runtime: AbstractRuntime\n</code></pre> <p>Returns the runtime if running.</p> <p>Raises:</p> Type Description <code>DeploymentNotStartedError</code> <p>If the deployment is not started.</p>"},{"location":"api/deployments/abstract/#swerex.deployment.abstract.AbstractDeployment.is_alive","title":"is_alive  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> <p>Checks if the runtime is alive. The return value can be tested with bool().</p> Source code in <code>swerex/deployment/abstract.py</code> <pre><code>@abstractmethod\nasync def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    \"\"\"Checks if the runtime is alive. The return value can be\n    tested with bool().\n    \"\"\"\n</code></pre>"},{"location":"api/deployments/abstract/#swerex.deployment.abstract.AbstractDeployment.start","title":"start  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>start(*args, **kwargs)\n</code></pre> Source code in <code>swerex/deployment/abstract.py</code> <pre><code>@abstractmethod\nasync def start(self, *args, **kwargs): ...\n</code></pre>"},{"location":"api/deployments/abstract/#swerex.deployment.abstract.AbstractDeployment.stop","title":"stop  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>stop(*args, **kwargs)\n</code></pre> Source code in <code>swerex/deployment/abstract.py</code> <pre><code>@abstractmethod\nasync def stop(self, *args, **kwargs): ...\n</code></pre>"},{"location":"api/deployments/docker/","title":"Docker","text":""},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment","title":"swerex.deployment.docker.DockerDeployment","text":"<pre><code>DockerDeployment(image_name: str, *, port: int = 8000, docker_args: list[str] | None = None)\n</code></pre> <p>               Bases: <code>AbstractDeployment</code></p> <p>Deployment to local docker image.</p> <p>Parameters:</p> Name Type Description Default <code>image_name</code> <code>str</code> <p>The name of the docker image to use.</p> required <code>port</code> <code>int</code> <p>The port that is being exposed by the docker container</p> <code>8000</code> <code>docker_args</code> <code>list[str] | None</code> <p>Additional arguments to pass to the docker run command.</p> <code>None</code> Source code in <code>swerex/deployment/docker.py</code> <pre><code>def __init__(self, image_name: str, *, port: int = 8000, docker_args: list[str] | None = None):\n    \"\"\"Deployment to local docker image.\n\n    Args:\n        image_name: The name of the docker image to use.\n        port: The port that is being exposed by the docker container\n        docker_args: Additional arguments to pass to the docker run command.\n    \"\"\"\n    self._image_name = image_name\n    self._runtime: RemoteRuntime | None = None\n    self._port = port\n    self._container_process = None\n    if docker_args is None:\n        docker_args = []\n    self._docker_args = docker_args\n    self._container_name = None\n    self.logger = get_logger(\"deploy\")\n    self._runtime_timeout = 0.15\n</code></pre>"},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment.container_name","title":"container_name  <code>property</code>","text":"<pre><code>container_name: str | None\n</code></pre>"},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = get_logger('deploy')\n</code></pre>"},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment.runtime","title":"runtime  <code>property</code>","text":"<pre><code>runtime: RemoteRuntime\n</code></pre>"},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment.is_alive","title":"is_alive  <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> Source code in <code>swerex/deployment/docker.py</code> <pre><code>async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    if self._runtime is None:\n        msg = \"Runtime not started\"\n        raise RuntimeError(msg)\n    if self._container_process is None:\n        msg = \"Container process not started\"\n        raise RuntimeError(msg)\n    if self._container_process.poll() is not None:\n        msg = \"Container process terminated.\"\n        output = \"stdout:\\n\" + self._container_process.stdout.read().decode()  # type: ignore\n        output += \"\\nstderr:\\n\" + self._container_process.stderr.read().decode()  # type: ignore\n        msg += \"\\n\" + output\n        raise RuntimeError(msg)\n    return await self._runtime.is_alive(timeout=timeout)\n</code></pre>"},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment.start","title":"start  <code>async</code>","text":"<pre><code>start(*, timeout: float | None = None)\n</code></pre> Source code in <code>swerex/deployment/docker.py</code> <pre><code>async def start(\n    self,\n    *,\n    timeout: float | None = None,\n):\n    assert self._container_name is None\n    self._container_name = self._get_container_name()\n    token = self._get_token()\n    cmds = [\n        \"docker\",\n        \"run\",\n        \"--rm\",\n        \"-p\",\n        f\"{self._port}:8000\",\n        *self._docker_args,\n        \"--name\",\n        self._container_name,\n        self._image_name,\n        REMOTE_EXECUTABLE_NAME,\n        \"--auth-token\",\n        token,\n    ]\n    self.logger.info(\n        f\"Starting container {self._container_name} with image {self._image_name} serving on port {self._port}\"\n    )\n    self.logger.debug(f\"Command: {' '.join(cmds)}\")\n    self._container_process = subprocess.Popen(cmds, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    self.logger.info(f\"Starting runtime at {self._port}\")\n    self._runtime = RemoteRuntime(port=self._port, timeout=self._runtime_timeout, auth_token=token)\n    t0 = time.time()\n    await self._wait_until_alive(timeout=timeout)\n    self.logger.info(f\"Runtime started in {time.time() - t0:.2f}s\")\n</code></pre>"},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> Source code in <code>swerex/deployment/docker.py</code> <pre><code>async def stop(self):\n    if self._runtime is not None:\n        await self._runtime.close()\n        self._runtime = None\n    if self._container_process is not None:\n        self._container_process.terminate()\n        self._container_process = None\n    self._container_name = None\n</code></pre>"},{"location":"api/deployments/fargate/","title":"Fargate","text":""},{"location":"api/deployments/fargate/#swerex.deployment.fargate.FargateDeployment","title":"swerex.deployment.fargate.FargateDeployment","text":"<pre><code>FargateDeployment(image_name: str, port: int = 8880, cluster_name: str = 'swe-rex-cluster', execution_role_prefix: str = 'swe-rex-execution-role', task_definition_prefix: str = 'swe-rex-task', log_group: str | None = '/ecs/swe-rex-deployment', security_group_prefix: str = 'swe-rex-deployment-sg', fargate_args: dict | None = None, container_timeout: float = 60 * 15)\n</code></pre> <p>               Bases: <code>AbstractDeployment</code></p> Source code in <code>swerex/deployment/fargate.py</code> <pre><code>def __init__(\n    self,\n    image_name: str,\n    port: int = 8880,\n    cluster_name: str = \"swe-rex-cluster\",\n    execution_role_prefix: str = \"swe-rex-execution-role\",\n    task_definition_prefix: str = \"swe-rex-task\",\n    log_group: str | None = \"/ecs/swe-rex-deployment\",\n    security_group_prefix: str = \"swe-rex-deployment-sg\",\n    fargate_args: dict | None = None,\n    container_timeout: float = 60 * 15,\n):\n    self._image_name = image_name\n    self._runtime: RemoteRuntime | None = None\n    self._port = port\n    self._container_process = None\n    self._container_name = None\n    if fargate_args is None:\n        fargate_args = {}\n    self._fargate_args = fargate_args\n    self._container_timeout = container_timeout\n    self._cluster_name = cluster_name\n    self._execution_role_prefix = execution_role_prefix\n    self._task_definition_prefix = task_definition_prefix\n    self._log_group = log_group\n    self._security_group_prefix = security_group_prefix\n    self.logger = get_logger(\"deploy\")\n    # we need to setup ecs and ec2 to run containers\n    self._cluster_arn = None\n    self._execution_role_arn = None\n    self._vpc_id = None\n    self._subnet_id = None\n    self._task_arn = None\n    self._security_group_id = None\n    self._init_aws()\n</code></pre>"},{"location":"api/deployments/fargate/#swerex.deployment.fargate.FargateDeployment.container_name","title":"container_name  <code>property</code>","text":"<pre><code>container_name: str | None\n</code></pre>"},{"location":"api/deployments/fargate/#swerex.deployment.fargate.FargateDeployment.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = get_logger('deploy')\n</code></pre>"},{"location":"api/deployments/fargate/#swerex.deployment.fargate.FargateDeployment.runtime","title":"runtime  <code>property</code>","text":"<pre><code>runtime: RemoteRuntime\n</code></pre>"},{"location":"api/deployments/fargate/#swerex.deployment.fargate.FargateDeployment.is_alive","title":"is_alive  <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> Source code in <code>swerex/deployment/fargate.py</code> <pre><code>async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    if self._runtime is None:\n        msg = \"Runtime not started\"\n        raise RuntimeError(msg)\n    if self._task_arn is None:\n        msg = \"Container process not started.\"\n        raise RuntimeError(msg)\n    else:\n        # check if the task is running\n        ecs_client = boto3.client(\"ecs\")\n        task_details = ecs_client.describe_tasks(cluster=self._cluster_arn, tasks=[self._task_arn])\n        if task_details[\"tasks\"][0][\"lastStatus\"] != \"RUNNING\":\n            msg = f\"Container process not running: {task_details['tasks'][0]['lastStatus']}\"\n            raise RuntimeError(msg)\n    return await self._runtime.is_alive(timeout=timeout)\n</code></pre>"},{"location":"api/deployments/fargate/#swerex.deployment.fargate.FargateDeployment.start","title":"start  <code>async</code>","text":"<pre><code>start(*, timeout: float = 120)\n</code></pre> Source code in <code>swerex/deployment/fargate.py</code> <pre><code>async def start(\n    self,\n    *,\n    timeout: float = 120,\n):\n    self._container_name = self._get_container_name()\n    self.logger.info(f\"Starting runtime with container name {self._container_name}\")\n    token = self._get_token()\n    self._task_arn = run_fargate_task(\n        command=self._get_command(token=token),\n        name=self._container_name,\n        task_definition_arn=self._task_definition[\"taskDefinitionArn\"],\n        subnet_id=self._subnet_id,\n        security_group_id=self._security_group_id,\n        cluster_arn=self._cluster_arn,\n        **self._fargate_args,\n    )\n    self.logger.info(f\"Container task submitted: {self._task_arn} - waiting for it to start...\")\n    # wait until the container is running\n    t0 = time.time()\n    ecs_client = boto3.client(\"ecs\")\n    waiter = ecs_client.get_waiter(\"tasks_running\")\n    waiter.wait(cluster=self._cluster_arn, tasks=[self._task_arn])\n    self.logger.info(f\"Fargate container started in {time.time() - t0:.2f}s\")\n    if self._log_group:\n        try:\n            log_url = get_cloudwatch_log_url(\n                task_arn=self._task_arn,\n                task_definition=self._task_definition,\n                container_name=self._container_name,\n            )\n            self.logger.info(f\"Monitor logs at: {log_url}\")\n        except Exception as e:\n            self.logger.warning(f\"Failed to get CloudWatch Logs URL: {str(e)}\")\n    public_ip = get_public_ip(self._task_arn, self._cluster_arn)\n    self.logger.info(f\"Container public IP: {public_ip}\")\n    self._runtime = RemoteRuntime(host=public_ip, port=self._port, auth_token=token)\n    t0 = time.time()\n    await self._wait_until_alive(timeout=timeout)\n    self.logger.info(f\"Runtime started in {time.time() - t0:.2f}s\")\n</code></pre>"},{"location":"api/deployments/fargate/#swerex.deployment.fargate.FargateDeployment.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> Source code in <code>swerex/deployment/fargate.py</code> <pre><code>async def stop(self):\n    if self._runtime is not None:\n        await self._runtime.close()\n        self._runtime = None\n    if self._task_arn is not None:\n        ecs_client = boto3.client(\"ecs\")\n        ecs_client.stop_task(task=self._task_arn, cluster=self._cluster_arn)\n    self._task_arn = None\n    self._container_name = None\n</code></pre>"},{"location":"api/deployments/local/","title":"Local","text":""},{"location":"api/deployments/local/#swerex.deployment.local.LocalDeployment","title":"swerex.deployment.local.LocalDeployment","text":"<pre><code>LocalDeployment()\n</code></pre> <p>               Bases: <code>AbstractDeployment</code></p> <p>The most boring of the deployment classes. This class does nothing but wrap around <code>Runtime</code> so you can switch out your deployment method.</p> Source code in <code>swerex/deployment/local.py</code> <pre><code>def __init__(\n    self,\n):\n    \"\"\"The most boring of the deployment classes.\n    This class does nothing but wrap around `Runtime` so you can switch out\n    your deployment method.\n    \"\"\"\n    self._runtime = None\n    self.logger = get_logger(\"deploy\")  # type: ignore\n</code></pre>"},{"location":"api/deployments/local/#swerex.deployment.local.LocalDeployment.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = get_logger('deploy')\n</code></pre>"},{"location":"api/deployments/local/#swerex.deployment.local.LocalDeployment.runtime","title":"runtime  <code>property</code>","text":"<pre><code>runtime: Runtime\n</code></pre>"},{"location":"api/deployments/local/#swerex.deployment.local.LocalDeployment.is_alive","title":"is_alive  <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> Source code in <code>swerex/deployment/local.py</code> <pre><code>async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    if self._runtime is None:\n        return IsAliveResponse(is_alive=False, message=\"Runtime is None.\")\n    return await self._runtime.is_alive(timeout=timeout)\n</code></pre>"},{"location":"api/deployments/local/#swerex.deployment.local.LocalDeployment.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> Source code in <code>swerex/deployment/local.py</code> <pre><code>async def start(self):\n    self._runtime = Runtime()\n</code></pre>"},{"location":"api/deployments/local/#swerex.deployment.local.LocalDeployment.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> Source code in <code>swerex/deployment/local.py</code> <pre><code>async def stop(self):\n    if self._runtime is not None:\n        await self._runtime.close()\n        self._runtime = None\n</code></pre>"},{"location":"api/deployments/modal/","title":"Modal","text":""},{"location":"api/deployments/modal/#swerex.deployment.modal.ModalDeployment","title":"swerex.deployment.modal.ModalDeployment","text":"<pre><code>ModalDeployment(image: str | Image | PurePath, container_timeout: float = 1800, runtime_timeout: float = 0.4, modal_sandbox_kwargs: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>AbstractDeployment</code></p> <p>Deployment for modal.com. The deployment will only start when the <code>start</code> method is being called.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | Image | PurePath</code> <p>Image to use for the deployment. One of the following: 1. <code>modal.Image</code> object 2. Path to a Dockerfile 3. Dockerhub image name (e.g. <code>python:3.11-slim</code>) 4. ECR image name (e.g. <code>123456789012.dkr.ecr.us-east-1.amazonaws.com/my-image:tag</code>)</p> required <code>container_timeout</code> <code>float</code> <code>1800</code> <code>runtime_timeout</code> <code>float</code> <code>0.4</code> <code>modal_sandbox_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional arguments to pass to <code>modal.Sandbox.create</code></p> <code>None</code> Source code in <code>swerex/deployment/modal.py</code> <pre><code>def __init__(\n    self,\n    image: str | modal.Image | PurePath,\n    container_timeout: float = 1800,\n    runtime_timeout: float = 0.4,\n    modal_sandbox_kwargs: dict[str, Any] | None = None,\n):\n    \"\"\"Deployment for modal.com. The deployment will only start when the\n    `start` method is being called.\n\n    Args:\n        image: Image to use for the deployment. One of the following:\n            1. `modal.Image` object\n            2. Path to a Dockerfile\n            3. Dockerhub image name (e.g. `python:3.11-slim`)\n            4. ECR image name (e.g. `123456789012.dkr.ecr.us-east-1.amazonaws.com/my-image:tag`)\n        container_timeout:\n        runtime_timeout:\n        modal_sandbox_kwargs: Additional arguments to pass to `modal.Sandbox.create`\n    \"\"\"\n    self._image = _ImageBuilder().auto(image)\n    self._runtime: RemoteRuntime | None = None\n    self._container_timeout = container_timeout\n    self._sandbox: modal.Sandbox | None = None\n    self._port = 8880\n    self.logger = get_logger(\"deploy\")\n    self._app = modal.App.lookup(\"swe-rex\", create_if_missing=True)\n    self._user = _get_modal_user()\n    self._runtime_timeout = runtime_timeout\n    if modal_sandbox_kwargs is None:\n        modal_sandbox_kwargs = {}\n    self._modal_kwargs = modal_sandbox_kwargs\n</code></pre>"},{"location":"api/deployments/modal/#swerex.deployment.modal.ModalDeployment.app","title":"app  <code>property</code>","text":"<pre><code>app: App\n</code></pre> <p>Returns the modal app</p> <p>Raises:</p> Type Description <code>DeploymentNotStartedError</code> <p>If the deployment is not started.</p>"},{"location":"api/deployments/modal/#swerex.deployment.modal.ModalDeployment.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = get_logger('deploy')\n</code></pre>"},{"location":"api/deployments/modal/#swerex.deployment.modal.ModalDeployment.runtime","title":"runtime  <code>property</code>","text":"<pre><code>runtime: RemoteRuntime\n</code></pre>"},{"location":"api/deployments/modal/#swerex.deployment.modal.ModalDeployment.sandbox","title":"sandbox  <code>property</code>","text":"<pre><code>sandbox: Sandbox\n</code></pre> <p>Returns the modal sandbox</p> <p>Raises:</p> Type Description <code>DeploymentNotStartedError</code> <p>If the deployment is not started.</p>"},{"location":"api/deployments/modal/#swerex.deployment.modal.ModalDeployment.get_modal_log_url","title":"get_modal_log_url","text":"<pre><code>get_modal_log_url() -&gt; str\n</code></pre> <p>Returns URL to modal logs</p> Source code in <code>swerex/deployment/modal.py</code> <pre><code>def get_modal_log_url(self) -&gt; str:\n    \"\"\"Returns URL to modal logs\"\"\"\n    return f\"https://modal.com/apps/{self._user}/main/deployed/{self.app.name}?activeTab=logs&amp;taskId={self.sandbox._get_task_id()}\"\n</code></pre>"},{"location":"api/deployments/modal/#swerex.deployment.modal.ModalDeployment.is_alive","title":"is_alive  <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> Source code in <code>swerex/deployment/modal.py</code> <pre><code>async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    if self._runtime is None or self._sandbox is None:\n        raise DeploymentNotStartedError()\n    if self._sandbox.poll() is not None:\n        msg = \"Container process terminated.\"\n        output = \"stdout:\\n\" + self._sandbox.stdout.read()  # type: ignore\n        output += \"\\nstderr:\\n\" + self._sandbox.stderr.read()  # type: ignore\n        msg += \"\\n\" + output\n        raise RuntimeError(msg)\n    return await self._runtime.is_alive(timeout=timeout)\n</code></pre>"},{"location":"api/deployments/modal/#swerex.deployment.modal.ModalDeployment.start","title":"start  <code>async</code>","text":"<pre><code>start(*, timeout: float = 60)\n</code></pre> Source code in <code>swerex/deployment/modal.py</code> <pre><code>async def start(\n    self,\n    *,\n    timeout: float = 60,\n):\n    self.logger.info(\"Starting modal sandbox\")\n    t0 = time.time()\n    token = self._get_token()\n    self._sandbox = modal.Sandbox.create(\n        \"/bin/bash\",\n        \"-c\",\n        self._start_swerex_cmd(token),\n        image=self._image,\n        timeout=int(self._container_timeout),\n        unencrypted_ports=[self._port],\n        app=self._app,\n        **self._modal_kwargs,\n    )\n    tunnel = self._sandbox.tunnels()[self._port]\n    self.logger.info(f\"Sandbox ({self._sandbox.object_id}) created in {time.time() - t0:.2f}s\")\n    self.logger.info(f\"Check sandbox logs at {self.get_modal_log_url()}\")\n    self.logger.info(f\"Sandbox created with id {self._sandbox.object_id}\")\n    await asyncio.sleep(1)\n    self.logger.info(f\"Starting runtime at {tunnel.url}\")\n    self._runtime = RemoteRuntime(host=tunnel.url, timeout=self._runtime_timeout, auth_token=token)\n    t0 = time.time()\n    await self._wait_until_alive(timeout=timeout)\n    self.logger.info(f\"Runtime started in {time.time() - t0:.2f}s\")\n</code></pre>"},{"location":"api/deployments/modal/#swerex.deployment.modal.ModalDeployment.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> Source code in <code>swerex/deployment/modal.py</code> <pre><code>async def stop(self):\n    if self._runtime is not None:\n        await self._runtime.close()\n        self._runtime = None\n    if self._sandbox is not None and not self._sandbox.poll():\n        self._sandbox.terminate()\n    self._sandbox = None\n    self._app = None\n</code></pre>"},{"location":"api/runtimes/abstract/","title":"Abstract","text":""},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime","title":"swerex.runtime.abstract.AbstractRuntime","text":"<p>               Bases: <code>ABC</code></p> <p>This is the main entry point for running stuff.</p> <p>It keeps track of all the sessions (individual repls) that are currently open.</p>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close() -&gt; CloseResponse\n</code></pre> <p>Closes the runtime.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; CloseResponse:\n    \"\"\"Closes the runtime.\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.close_session","title":"close_session  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close_session(request: CloseSessionRequest)\n</code></pre> <p>Closes a shell session.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def close_session(self, request: CloseSessionRequest):\n    \"\"\"Closes a shell session.\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.create_session","title":"create_session  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>create_session(request: CreateSessionRequest) -&gt; CreateSessionResponse\n</code></pre> <p>Creates a new session.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def create_session(self, request: CreateSessionRequest) -&gt; CreateSessionResponse:\n    \"\"\"Creates a new session.\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.execute","title":"execute  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>execute(command: Command) -&gt; CommandResponse\n</code></pre> <p>Executes a command (independent of any shell session).</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def execute(self, command: Command) -&gt; CommandResponse:\n    \"\"\"Executes a command (independent of any shell session).\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.is_alive","title":"is_alive  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> <p>Checks if the runtime is alive.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    \"\"\"Checks if the runtime is alive.\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.read_file","title":"read_file  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>read_file(request: ReadFileRequest) -&gt; ReadFileResponse\n</code></pre> <p>Reads a file</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def read_file(self, request: ReadFileRequest) -&gt; ReadFileResponse:\n    \"\"\"Reads a file\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.run_in_session","title":"run_in_session  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run_in_session(action: Action) -&gt; Observation\n</code></pre> <p>Runs a command in a session.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def run_in_session(self, action: Action) -&gt; Observation:\n    \"\"\"Runs a command in a session.\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.upload","title":"upload  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>upload(request: UploadRequest) -&gt; UploadResponse\n</code></pre> <p>Uploads a file</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def upload(self, request: UploadRequest) -&gt; UploadResponse:\n    \"\"\"Uploads a file\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.write_file","title":"write_file  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>write_file(request: WriteFileRequest) -&gt; WriteFileResponse\n</code></pre> <p>Writes a file</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def write_file(self, request: WriteFileRequest) -&gt; WriteFileResponse:\n    \"\"\"Writes a file\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/data/","title":"Data","text":"<p>Classes:</p> Name Description <code>Action</code> <p>An action to run in a session.</p> <code>BashIncorrectSyntaxError</code> <p>Before running a bash command, we check for syntax errors.</p> <code>CloseResponse</code> <code>CloseSessionRequest</code> <code>CloseSessionResponse</code> <code>Command</code> <p>A command to run as a subprocess.</p> <code>CommandResponse</code> <code>CommandTimeoutError</code> <code>CreateSessionRequest</code> <code>CreateSessionResponse</code> <code>IsAliveResponse</code> <p>Response to the is_alive request.</p> <code>NoExitCodeError</code> <code>Observation</code> <code>ReadFileRequest</code> <code>ReadFileResponse</code> <code>SessionDoesNotExistError</code> <code>SessionExistsError</code> <code>SweRexception</code> <code>UninitializedShellError</code> <code>UploadRequest</code> <code>UploadResponse</code> <code>WriteFileRequest</code> <code>WriteFileResponse</code>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action","title":"Action  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An action to run in a session.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: str\n</code></pre> <p>The command to run.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action.expect","title":"expect  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>expect: list[str] = []\n</code></pre> <p>Outputs to expect in addition to the PS1</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action.is_interactive_command","title":"is_interactive_command  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_interactive_command: bool = False\n</code></pre> <p>For a non-exiting command to an interactive program (e.g., gdb), set this to True.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action.is_interactive_quit","title":"is_interactive_quit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_interactive_quit: bool = False\n</code></pre> <p>This will disable checking for exit codes, since the command won't terminate. If the command is something like \"quit\" and should terminate the interactive program, set this to False.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action.session","title":"session  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>session: str = 'default'\n</code></pre> <p>The session to run the command in.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: float | None = None\n</code></pre> <p>The timeout for the command. None means no timeout.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.BashIncorrectSyntaxError","title":"BashIncorrectSyntaxError","text":"<p>               Bases: <code>SweRexception</code>, <code>RuntimeError</code></p> <p>Before running a bash command, we check for syntax errors. This is the error message for those syntax errors.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CloseResponse","title":"CloseResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CloseSessionRequest","title":"CloseSessionRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CloseSessionRequest.session","title":"session  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>session: str = 'default'\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CloseSessionResponse","title":"CloseSessionResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Command","title":"Command  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A command to run as a subprocess.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Command.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: str | list[str]\n</code></pre> <p>The command to run. Should be a list of strings (recommended because of automatic escaping of spaces etc.) unless you set <code>shell=True</code> (i.e., exactly like with <code>subprocess.run()</code>).</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Command.shell","title":"shell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shell: bool = False\n</code></pre> <p>Same as the <code>subprocess.run()</code> <code>shell</code> argument.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Command.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: float | None = None\n</code></pre> <p>The timeout for the command. None means no timeout.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CommandResponse","title":"CommandResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>stdout</code>                 (<code>str</code>)             </li> <li> <code>stderr</code>                 (<code>str</code>)             </li> <li> <code>exit_code</code>                 (<code>int | None</code>)             </li> </ul>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CommandResponse.exit_code","title":"exit_code  <code>pydantic-field</code>","text":"<pre><code>exit_code: int | None = None\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CommandResponse.stderr","title":"stderr  <code>pydantic-field</code>","text":"<pre><code>stderr: str = ''\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CommandResponse.stdout","title":"stdout  <code>pydantic-field</code>","text":"<pre><code>stdout: str = ''\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CommandTimeoutError","title":"CommandTimeoutError","text":"<p>               Bases: <code>SweRexception</code>, <code>RuntimeError</code></p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CreateSessionRequest","title":"CreateSessionRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CreateSessionRequest.session","title":"session  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>session: str = 'default'\n</code></pre> <p>The name of the session to create.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CreateSessionRequest.startup_source","title":"startup_source  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>startup_source: list[str] = []\n</code></pre> <p>Source the following files before running commands. The reason this gets a special treatment is that these files often overwrite PS1, which we need to reset.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CreateSessionResponse","title":"CreateSessionResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>output</code>                 (<code>str</code>)             </li> </ul>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CreateSessionResponse.output","title":"output  <code>pydantic-field</code>","text":"<pre><code>output: str = ''\n</code></pre> <p>Output from starting the session.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.IsAliveResponse","title":"IsAliveResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response to the is_alive request.</p> <p>You can test the result with bool().</p> <p>Fields:</p> <ul> <li> <code>is_alive</code>                 (<code>bool</code>)             </li> <li> <code>message</code>                 (<code>str</code>)             </li> </ul>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.IsAliveResponse.is_alive","title":"is_alive  <code>pydantic-field</code>","text":"<pre><code>is_alive: bool\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.IsAliveResponse.message","title":"message  <code>pydantic-field</code>","text":"<pre><code>message: str = ''\n</code></pre> <p>Error message if is_alive is False.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.NoExitCodeError","title":"NoExitCodeError","text":"<p>               Bases: <code>SweRexception</code>, <code>RuntimeError</code></p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Observation","title":"Observation  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>output</code>                 (<code>str</code>)             </li> <li> <code>exit_code</code>                 (<code>int | None</code>)             </li> <li> <code>failure_reason</code>                 (<code>str</code>)             </li> <li> <code>expect_string</code>                 (<code>str</code>)             </li> </ul>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Observation.exit_code","title":"exit_code  <code>pydantic-field</code>","text":"<pre><code>exit_code: int | None = None\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Observation.expect_string","title":"expect_string  <code>pydantic-field</code>","text":"<pre><code>expect_string: str = ''\n</code></pre> <p>Which of the expect strings was matched to terminate the command. Empty string if the command timed out etc.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Observation.failure_reason","title":"failure_reason  <code>pydantic-field</code>","text":"<pre><code>failure_reason: str = ''\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Observation.output","title":"output  <code>pydantic-field</code>","text":"<pre><code>output: str = ''\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.ReadFileRequest","title":"ReadFileRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.ReadFileRequest.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.ReadFileResponse","title":"ReadFileResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>content</code>                 (<code>str</code>)             </li> </ul>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.ReadFileResponse.content","title":"content  <code>pydantic-field</code>","text":"<pre><code>content: str = ''\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.SessionDoesNotExistError","title":"SessionDoesNotExistError","text":"<p>               Bases: <code>SweRexception</code>, <code>ValueError</code></p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.SessionExistsError","title":"SessionExistsError","text":"<p>               Bases: <code>SweRexception</code>, <code>ValueError</code></p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.SweRexception","title":"SweRexception","text":"<p>               Bases: <code>RuntimeError</code></p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.UninitializedShellError","title":"UninitializedShellError","text":"<p>               Bases: <code>SweRexception</code>, <code>ValueError</code></p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.UploadRequest","title":"UploadRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>source_path</code>                 (<code>str</code>)             </li> <li> <code>target_path</code>                 (<code>str</code>)             </li> </ul>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.UploadRequest.source_path","title":"source_path  <code>pydantic-field</code>","text":"<pre><code>source_path: str\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.UploadRequest.target_path","title":"target_path  <code>pydantic-field</code>","text":"<pre><code>target_path: str\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.UploadResponse","title":"UploadResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.WriteFileRequest","title":"WriteFileRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.WriteFileRequest.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.WriteFileRequest.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.WriteFileResponse","title":"WriteFileResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/runtimes/local/","title":"Local","text":""},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime","title":"swerex.runtime.local.Runtime","text":"<pre><code>Runtime()\n</code></pre> <p>               Bases: <code>AbstractRuntime</code></p> <p>A Runtime that runs locally and actually executes commands in a shell. If you are deploying to Modal/Fargate/etc., this class will be running within the docker container on Modal/Fargate/etc.</p> Source code in <code>swerex/runtime/local.py</code> <pre><code>def __init__(self):\n    \"\"\"A Runtime that runs locally and actually executes commands in a shell.\n    If you are deploying to Modal/Fargate/etc., this class will be running within the docker container\n    on Modal/Fargate/etc.\n    \"\"\"\n    self._sessions: dict[str, Session] = {}\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.sessions","title":"sessions  <code>property</code>","text":"<pre><code>sessions: dict[str, Session]\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; CloseResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def close(self) -&gt; CloseResponse:\n    await asyncio.gather(*[self.close_session(CloseSessionRequest(session=s)) for s in self.sessions])\n    return CloseResponse()\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.close_session","title":"close_session  <code>async</code>","text":"<pre><code>close_session(request: CloseSessionRequest) -&gt; CloseSessionResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def close_session(self, request: CloseSessionRequest) -&gt; CloseSessionResponse:\n    if request.session not in self.sessions:\n        msg = f\"session {request.session!r} does not exist\"\n        raise SessionDoesNotExistError(msg)\n    out = await self.sessions[request.session].close()\n    del self.sessions[request.session]\n    return out\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.create_session","title":"create_session  <code>async</code>","text":"<pre><code>create_session(request: CreateSessionRequest) -&gt; CreateSessionResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def create_session(self, request: CreateSessionRequest) -&gt; CreateSessionResponse:\n    if request.session in self.sessions:\n        msg = f\"session {request.session} already exists\"\n        raise SessionExistsError(msg)\n    shell = Session(request)\n    self.sessions[request.session] = shell\n    return await shell.start()\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(command: Command) -&gt; CommandResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def execute(self, command: Command) -&gt; CommandResponse:\n    try:\n        result = subprocess.run(command.command, shell=command.shell, timeout=command.timeout, capture_output=True)\n        return CommandResponse(\n            stdout=result.stdout.decode(errors=\"backslashreplace\"),\n            stderr=result.stderr.decode(errors=\"backslashreplace\"),\n            exit_code=result.returncode,\n        )\n    except subprocess.TimeoutExpired as e:\n        msg = f\"Timeout ({command.timeout}s) exceeded while running command\"\n        raise CommandTimeoutError(msg) from e\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.is_alive","title":"is_alive  <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    return IsAliveResponse(is_alive=True)\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.read_file","title":"read_file  <code>async</code>","text":"<pre><code>read_file(request: ReadFileRequest) -&gt; ReadFileResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def read_file(self, request: ReadFileRequest) -&gt; ReadFileResponse:\n    content = Path(request.path).read_text()\n    return ReadFileResponse(content=content)\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.run_in_session","title":"run_in_session  <code>async</code>","text":"<pre><code>run_in_session(action: Action) -&gt; Observation\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def run_in_session(self, action: Action) -&gt; Observation:\n    if action.session not in self.sessions:\n        msg = f\"session {action.session!r} does not exist\"\n        raise SessionDoesNotExistError(msg)\n    return await self.sessions[action.session].run(action)\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.upload","title":"upload  <code>async</code>","text":"<pre><code>upload(request: UploadRequest) -&gt; UploadResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def upload(self, request: UploadRequest) -&gt; UploadResponse:\n    if Path(request.source_path).is_dir():\n        shutil.copytree(request.source_path, request.target_path)\n    else:\n        shutil.copy(request.source_path, request.target_path)\n    return UploadResponse()\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.write_file","title":"write_file  <code>async</code>","text":"<pre><code>write_file(request: WriteFileRequest) -&gt; WriteFileResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def write_file(self, request: WriteFileRequest) -&gt; WriteFileResponse:\n    Path(request.path).parent.mkdir(parents=True, exist_ok=True)\n    Path(request.path).write_text(request.content)\n    return WriteFileResponse()\n</code></pre>"},{"location":"api/runtimes/remote/","title":"Remote","text":""},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime","title":"swerex.runtime.remote.RemoteRuntime","text":"<pre><code>RemoteRuntime(*, auth_token: str, host: str = 'http://127.0.0.1', port: int | None = None, timeout: float = 0.15)\n</code></pre> <p>               Bases: <code>AbstractRuntime</code></p> <p>A runtime that connects to a remote server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host to connect to.</p> <code>'http://127.0.0.1'</code> <code>port</code> <code>int | None</code> <p>The port to connect to.</p> <code>None</code> <code>token</code> <p>The token to use for authentication</p> required <code>timeout</code> <code>float</code> <p>The timeout to use for requests.</p> <code>0.15</code> Source code in <code>swerex/runtime/remote.py</code> <pre><code>def __init__(\n    self,\n    *,\n    auth_token: str,\n    host: str = \"http://127.0.0.1\",\n    port: int | None = None,\n    timeout: float = 0.15,\n):\n    \"\"\"A runtime that connects to a remote server.\n\n    Args:\n        host: The host to connect to.\n        port: The port to connect to.\n        token: The token to use for authentication\n        timeout: The timeout to use for requests.\n    \"\"\"\n    self.logger = get_logger(\"RR\")\n    if not host.startswith(\"http\"):\n        self.logger.warning(\"Host %s does not start with http, adding http://\", host)\n        host = f\"http://{host}\"\n    self.host = host\n    self.port = port\n    self._token = auth_token\n    self._timeout = timeout\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.host","title":"host  <code>instance-attribute</code>","text":"<pre><code>host = host\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = get_logger('RR')\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port = port\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; CloseResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def close(self) -&gt; CloseResponse:\n    return self._request(\"close\", None, CloseResponse)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.close_session","title":"close_session  <code>async</code>","text":"<pre><code>close_session(request: CloseSessionRequest) -&gt; CloseSessionResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def close_session(self, request: CloseSessionRequest) -&gt; CloseSessionResponse:\n    return self._request(\"close_session\", request, CloseSessionResponse)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.create_session","title":"create_session  <code>async</code>","text":"<pre><code>create_session(request: CreateSessionRequest) -&gt; CreateSessionResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def create_session(self, request: CreateSessionRequest) -&gt; CreateSessionResponse:\n    return self._request(\"create_session\", request, CreateSessionResponse)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(command: Command) -&gt; CommandResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def execute(self, command: Command) -&gt; CommandResponse:\n    return self._request(\"execute\", command, CommandResponse)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.is_alive","title":"is_alive  <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> <p>Checks if the runtime is alive.</p> <p>Internal server errors are thrown, everything else just has us return False together with the message.</p> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    \"\"\"Checks if the runtime is alive.\n\n    Internal server errors are thrown, everything else just has us return False\n    together with the message.\n    \"\"\"\n    try:\n        response = requests.get(\n            f\"{self._api_url}/is_alive\", headers=self._headers, timeout=self._get_timeout(timeout)\n        )\n        if response.status_code == 200:\n            return IsAliveResponse(**response.json())\n        elif response.status_code == 511:\n            exc_transfer = _ExceptionTransfer(**response.json()[\"swerexception\"])\n            self._handle_transfer_exception(exc_transfer)\n        msg = (\n            f\"Status code {response.status_code} from {self._api_url}/is_alive. \"\n            f\"Message: {response.json().get('detail')}\"\n        )\n        return IsAliveResponse(is_alive=False, message=msg)\n    except requests.RequestException:\n        msg = f\"Failed to connect to {self.host}\\n\"\n        msg += traceback.format_exc()\n        return IsAliveResponse(is_alive=False, message=msg)\n    except Exception:\n        msg = f\"Failed to connect to {self.host}\\n\"\n        msg += traceback.format_exc()\n        return IsAliveResponse(is_alive=False, message=msg)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.read_file","title":"read_file  <code>async</code>","text":"<pre><code>read_file(request: ReadFileRequest) -&gt; ReadFileResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def read_file(self, request: ReadFileRequest) -&gt; ReadFileResponse:\n    return self._request(\"read_file\", request, ReadFileResponse)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.run_in_session","title":"run_in_session  <code>async</code>","text":"<pre><code>run_in_session(action: Action) -&gt; Observation\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def run_in_session(self, action: Action) -&gt; Observation:\n    return self._request(\"run_in_session\", action, Observation)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.upload","title":"upload  <code>async</code>","text":"<pre><code>upload(request: UploadRequest) -&gt; UploadResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def upload(self, request: UploadRequest) -&gt; UploadResponse:\n    source = Path(request.source_path)\n    if source.is_dir():\n        with tempfile.TemporaryDirectory() as temp_dir:\n            zip_path = Path(temp_dir) / f\"{source.name}.zip\"\n            shutil.make_archive(str(zip_path.with_suffix(\"\")), \"zip\", source)\n            files = {\"file\": zip_path.open(\"rb\")}\n            data = {\"target_path\": request.target_path, \"unzip\": \"true\"}\n            response = requests.post(f\"{self._api_url}/upload\", files=files, data=data, headers=self._headers)\n            self._handle_response_errors(response)\n            return UploadResponse(**response.json())\n    else:\n        files = {\"file\": source.open(\"rb\")}\n        data = {\"target_path\": request.target_path, \"unzip\": \"false\"}\n        response = requests.post(f\"{self._api_url}/upload\", files=files, data=data, headers=self._headers)\n        self._handle_response_errors(response)\n        return UploadResponse(**response.json())\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.wait_until_alive","title":"wait_until_alive  <code>async</code>","text":"<pre><code>wait_until_alive(*, timeout: float | None = None)\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def wait_until_alive(self, *, timeout: float | None = None):\n    return await _wait_until_alive(self.is_alive, timeout=timeout)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.write_file","title":"write_file  <code>async</code>","text":"<pre><code>write_file(request: WriteFileRequest) -&gt; WriteFileResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def write_file(self, request: WriteFileRequest) -&gt; WriteFileResponse:\n    return self._request(\"write_file\", request, WriteFileResponse)\n</code></pre>"}]}