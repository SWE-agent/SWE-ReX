{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SWE-ReX","text":"<p>SWE-ReX is a runtime for interacting with sandboxed shell environments, allowing to effortlessly let your AI agent run anything from <code>ls</code> to interactive <code>pdb</code> sessions. Whether commands are executed locally or remotely in docker containers, on AWS, modal, or something else, your code remains the same.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>Let's take a look how SWE-ReX works:</p> <ol> <li>Your central entry point is one of the <code>Deployment</code> classes, depending on where your code should run. </li> <li>Your <code>Deployment</code> instances allows your to start your docker container, AWS instance, or whatever at the push of a button. That's right, no more fiddeling with the AWS console!</li> <li>After the <code>Deployment</code> has started your container somewhere, you are handed a <code>RemoteRuntime</code> instance.   This is your main interface for interacting with the environment. You can use it start new shell or interactive sessions, read and write files, execute one-off commands, etc.</li> </ol> <p></p> <p>Looking closer at the internals:</p> <ol> <li> <p>Within the container, we have a fastapi Server that transfers all request from the <code>RemoteRuntime</code> to the <code>LocalRuntime</code>.    The <code>LocalRuntime</code> has the exact same interface as the <code>RemoteRuntime</code> class and it is what actually executes the commands.    In fact, if you want to run something locally (or your whole codebase runs in a sandboxed environment), you can just use the <code>LocalRuntime</code> directly!    Both classes are absolutely interchangeable, in fact we even transfer any exceptions happening in the <code>LocalRuntime</code> to the <code>RemoteRuntime</code> transparently,    so you can easily catch and ignore certain errors.</p> </li> <li> <p>The <code>Runtime</code> class provides several methods for reading/writing files, an <code>execute</code> method for running arbitrary commands, but the most important one is <code>run_in_session</code>.    This method allows you to run a command in an existing shell session (or an interactive tool running inside of it) and return the output.    In fact, you can have multiple sessions open at the same time, running different commands and tools in parallel!</p> </li> </ol>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Here's a simple example:</p> <pre><code>import asyncio\n\nfrom swerex.deployment.local import LocalDeployment\nfrom swerex.runtime.abstract import Action as A\nfrom swerex.runtime.abstract import (\n    CloseSessionRequest,\n    CreateSessionRequest,\n)\n\ndeployment = LocalDeployment()\nasyncio.run(deployment.start())\nr = deployment.runtime\n# fmt: off\nprint(r.is_alive())\nprint(r.create_session(CreateSessionRequest()))\nprint(r.run_in_session(A(command=\"doesnexist\",)))\nprint(r.run_in_session(A(command=\"ls\",)))\nprint(r.run_in_session(A(command=\"python\", is_interactive_command=True, expect=[\"&gt;&gt;&gt; \"])))\nprint(r.run_in_session(A(command=\"print('hello world')\", is_interactive_command=True, expect=[\"&gt;&gt;&gt; \"])))\nprint(r.run_in_session(A(command=\"quit()\\n\", is_interactive_quit=True)))\nprint(r.run_in_session(A(command=\"echo 'test'\",)))\nprint(r.run_in_session(A(command=\"echo 'answer'\",)))\nprint(r.run_in_session(A(command=\"doesnexist\",)))\nprint(r.close_session(CloseSessionRequest()))\n# fmt: on\n</code></pre>"},{"location":"api/server/","title":"Server","text":""},{"location":"api/server/#swerex.server","title":"swerex.server","text":""},{"location":"api/server/#swerex.server.API_KEY","title":"API_KEY  <code>module-attribute</code>","text":"<pre><code>API_KEY = ''\n</code></pre>"},{"location":"api/server/#swerex.server.api_key_header","title":"api_key_header  <code>module-attribute</code>","text":"<pre><code>api_key_header = APIKeyHeader(name='X-API-Key')\n</code></pre>"},{"location":"api/server/#swerex.server.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate(request: Request, call_next)\n</code></pre> <p>Authenticate requests with an API key (if set).</p> Source code in <code>swerex/server.py</code> <pre><code>@app.middleware(\"http\")\nasync def authenticate(request: Request, call_next):\n    \"\"\"Authenticate requests with an API key (if set).\"\"\"\n    if API_KEY:\n        api_key = await api_key_header(request)\n        if api_key != API_KEY:\n            raise HTTPException(status_code=401, detail=\"Invalid API Key\")\n    return await call_next(request)\n</code></pre>"},{"location":"api/server/#swerex.server.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/close\")\nasync def close():\n    await runtime.close()\n    return CloseResponse()\n</code></pre>"},{"location":"api/server/#swerex.server.close_session","title":"close_session  <code>async</code>","text":"<pre><code>close_session(request: CloseSessionRequest)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/close_session\")\nasync def close_session(request: CloseSessionRequest):\n    return serialize_model(await runtime.close_session(request))\n</code></pre>"},{"location":"api/server/#swerex.server.create_session","title":"create_session  <code>async</code>","text":"<pre><code>create_session(request: CreateSessionRequest)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/create_session\")\nasync def create_session(request: CreateSessionRequest):\n    return serialize_model(await runtime.create_session(request))\n</code></pre>"},{"location":"api/server/#swerex.server.exception_handler","title":"exception_handler  <code>async</code>","text":"<pre><code>exception_handler(request: Request, exc: Exception)\n</code></pre> <p>We catch exceptions that are thrown by the runtime, serialize them to JSON and return them to the client so they can reraise them in their own code.</p> Source code in <code>swerex/server.py</code> <pre><code>@app.exception_handler(Exception)\nasync def exception_handler(request: Request, exc: Exception):\n    \"\"\"We catch exceptions that are thrown by the runtime, serialize them to JSON and\n    return them to the client so they can reraise them in their own code.\n    \"\"\"\n    if isinstance(exc, (HTTPException, StarletteHTTPException)):\n        return await http_exception_handler(request, exc)\n    _exc = _ExceptionTransfer(\n        message=str(exc), class_path=type(exc).__module__ + \".\" + type(exc).__name__, traceback=traceback.format_exc()\n    )\n    return JSONResponse(status_code=511, content={\"swerexception\": _exc.model_dump()})\n</code></pre>"},{"location":"api/server/#swerex.server.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(command: Command)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/execute\")\nasync def execute(command: Command):\n    return serialize_model(await runtime.execute(command))\n</code></pre>"},{"location":"api/server/#swerex.server.is_alive","title":"is_alive  <code>async</code>","text":"<pre><code>is_alive()\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.get(\"/is_alive\")\nasync def is_alive():\n    return serialize_model(await runtime.is_alive())\n</code></pre>"},{"location":"api/server/#swerex.server.read_file","title":"read_file  <code>async</code>","text":"<pre><code>read_file(request: ReadFileRequest)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/read_file\")\nasync def read_file(request: ReadFileRequest):\n    return serialize_model(await runtime.read_file(request))\n</code></pre>"},{"location":"api/server/#swerex.server.root","title":"root  <code>async</code>","text":"<pre><code>root()\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.get(\"/\")\nasync def root():\n    return {\"message\": \"hello world\"}\n</code></pre>"},{"location":"api/server/#swerex.server.run","title":"run  <code>async</code>","text":"<pre><code>run(action: Action)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/run_in_session\")\nasync def run(action: Action):\n    return serialize_model(await runtime.run_in_session(action))\n</code></pre>"},{"location":"api/server/#swerex.server.serialize_model","title":"serialize_model","text":"<pre><code>serialize_model(model)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>def serialize_model(model):\n    return model.model_dump() if hasattr(model, 'model_dump') else model.dict()\n</code></pre>"},{"location":"api/server/#swerex.server.upload","title":"upload  <code>async</code>","text":"<pre><code>upload(file: UploadFile = File(...), target_path: str = Form(...), unzip: bool = Form(False))\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/upload\")\nasync def upload(\n    file: UploadFile = File(...),\n    target_path: str = Form(...),  # type: ignore\n    unzip: bool = Form(False),\n):\n    target_path: Path = Path(target_path)\n    target_path.parent.mkdir(parents=True, exist_ok=True)\n    # First save the file to a temporary directory and potentially unzip it.\n    with tempfile.TemporaryDirectory() as temp_dir:\n        file_path = Path(temp_dir) / target_path.name\n        try:\n            with open(file_path, \"wb\") as f:\n                f.write(await file.read())\n        finally:\n            await file.close()\n        if unzip:\n            with zipfile.ZipFile(file_path, \"r\") as zip_ref:\n                zip_ref.extractall(target_path)\n        else:\n            shutil.copy(file_path, target_path)\n    return UploadResponse()\n</code></pre>"},{"location":"api/server/#swerex.server.write_file","title":"write_file  <code>async</code>","text":"<pre><code>write_file(request: WriteFileRequest)\n</code></pre> Source code in <code>swerex/server.py</code> <pre><code>@app.post(\"/write_file\")\nasync def write_file(request: WriteFileRequest):\n    return serialize_model(await runtime.write_file(request))\n</code></pre>"},{"location":"api/deployments/abstract/","title":"Abstract","text":""},{"location":"api/deployments/abstract/#swerex.deployment.abstract.AbstractDeployment","title":"swerex.deployment.abstract.AbstractDeployment","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>swerex/deployment/abstract.py</code> <pre><code>class AbstractDeployment(ABC):\n    @abstractmethod\n    async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n        \"\"\"Checks if the runtime is alive. The return value can be\n        tested with bool().\n        \"\"\"\n\n    @abstractmethod\n    async def start(self, *args, **kwargs): ...\n\n    @abstractmethod\n    async def stop(self, *args, **kwargs): ...\n\n    @property\n    @abstractmethod\n    def runtime(self) -&gt; AbstractRuntime: ...\n</code></pre>"},{"location":"api/deployments/abstract/#swerex.deployment.abstract.AbstractDeployment.runtime","title":"runtime  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>runtime: AbstractRuntime\n</code></pre>"},{"location":"api/deployments/abstract/#swerex.deployment.abstract.AbstractDeployment.is_alive","title":"is_alive  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> <p>Checks if the runtime is alive. The return value can be tested with bool().</p> Source code in <code>swerex/deployment/abstract.py</code> <pre><code>@abstractmethod\nasync def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    \"\"\"Checks if the runtime is alive. The return value can be\n    tested with bool().\n    \"\"\"\n</code></pre>"},{"location":"api/deployments/abstract/#swerex.deployment.abstract.AbstractDeployment.start","title":"start  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>start(*args, **kwargs)\n</code></pre> Source code in <code>swerex/deployment/abstract.py</code> <pre><code>@abstractmethod\nasync def start(self, *args, **kwargs): ...\n</code></pre>"},{"location":"api/deployments/abstract/#swerex.deployment.abstract.AbstractDeployment.stop","title":"stop  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>stop(*args, **kwargs)\n</code></pre> Source code in <code>swerex/deployment/abstract.py</code> <pre><code>@abstractmethod\nasync def stop(self, *args, **kwargs): ...\n</code></pre>"},{"location":"api/deployments/docker/","title":"Docker","text":""},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment","title":"swerex.deployment.docker.DockerDeployment","text":"<p>               Bases: <code>AbstractDeployment</code></p> Source code in <code>swerex/deployment/docker.py</code> <pre><code>class DockerDeployment(AbstractDeployment):\n    def __init__(self, image_name: str, port: int = 8000, docker_args: list[str] | None = None):\n        self._image_name = image_name\n        self._runtime: RemoteRuntime | None = None\n        self._port = port\n        self._container_process = None\n        if docker_args is None:\n            docker_args = []\n        self._docker_args = docker_args\n        self._container_name = None\n        self.logger = get_logger(\"deploy\")\n        self._runtime_timeout = 0.15\n\n    def _get_container_name(self) -&gt; str:\n        image_name_sanitized = \"\".join(c for c in self._image_name if c.isalnum() or c in \"-_.\")\n        return f\"{image_name_sanitized}-{uuid.uuid4()}\"\n\n    @property\n    def container_name(self) -&gt; str | None:\n        return self._container_name\n\n    async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n        if self._runtime is None:\n            msg = \"Runtime not started\"\n            raise RuntimeError(msg)\n        if self._container_process is None:\n            msg = \"Container process not started\"\n            raise RuntimeError(msg)\n        if self._container_process.poll() is not None:\n            msg = \"Container process terminated.\"\n            output = \"stdout:\\n\" + self._container_process.stdout.read().decode()  # type: ignore\n            output += \"\\nstderr:\\n\" + self._container_process.stderr.read().decode()  # type: ignore\n            msg += \"\\n\" + output\n            raise RuntimeError(msg)\n        return await self._runtime.is_alive(timeout=timeout)\n\n    async def _wait_until_alive(self, timeout: float | None = None):\n        return await _wait_until_alive(self.is_alive, timeout=timeout, function_timeout=self._runtime_timeout)\n\n    async def start(\n        self,\n        *,\n        timeout: float | None = None,\n    ):\n        assert self._container_name is None\n        self._container_name = self._get_container_name()\n        cmds = [\n            \"docker\",\n            \"run\",\n            \"--rm\",\n            \"-p\",\n            f\"{self._port}:8000\",\n            *self._docker_args,\n            \"--name\",\n            self._container_name,\n            self._image_name,\n            REMOTE_EXECUTABLE_NAME,\n        ]\n        self.logger.info(\n            f\"Starting container {self._container_name} with image {self._image_name} serving on port {self._port}\"\n        )\n        self.logger.debug(f\"Command: {' '.join(cmds)}\")\n        self._container_process = subprocess.Popen(cmds, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        self.logger.info(f\"Starting runtime at {self._port}\")\n        self._runtime = RemoteRuntime(port=self._port, timeout=self._runtime_timeout)\n        t0 = time.time()\n        await self._wait_until_alive(timeout=timeout)\n        self.logger.info(f\"Runtime started in {time.time() - t0:.2f}s\")\n\n    async def stop(self):\n        if self._runtime is not None:\n            await self._runtime.close()\n            self._runtime = None\n        if self._container_process is not None:\n            self._container_process.terminate()\n            self._container_process = None\n        self._container_name = None\n\n    @property\n    def runtime(self) -&gt; RemoteRuntime:\n        if self._runtime is None:\n            msg = \"Runtime not started\"\n            raise RuntimeError(msg)\n        return self._runtime\n</code></pre>"},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment.container_name","title":"container_name  <code>property</code>","text":"<pre><code>container_name: str | None\n</code></pre>"},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = get_logger('deploy')\n</code></pre>"},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment.runtime","title":"runtime  <code>property</code>","text":"<pre><code>runtime: RemoteRuntime\n</code></pre>"},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment.__init__","title":"__init__","text":"<pre><code>__init__(image_name: str, port: int = 8000, docker_args: list[str] | None = None)\n</code></pre> Source code in <code>swerex/deployment/docker.py</code> <pre><code>def __init__(self, image_name: str, port: int = 8000, docker_args: list[str] | None = None):\n    self._image_name = image_name\n    self._runtime: RemoteRuntime | None = None\n    self._port = port\n    self._container_process = None\n    if docker_args is None:\n        docker_args = []\n    self._docker_args = docker_args\n    self._container_name = None\n    self.logger = get_logger(\"deploy\")\n    self._runtime_timeout = 0.15\n</code></pre>"},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment.is_alive","title":"is_alive  <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> Source code in <code>swerex/deployment/docker.py</code> <pre><code>async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    if self._runtime is None:\n        msg = \"Runtime not started\"\n        raise RuntimeError(msg)\n    if self._container_process is None:\n        msg = \"Container process not started\"\n        raise RuntimeError(msg)\n    if self._container_process.poll() is not None:\n        msg = \"Container process terminated.\"\n        output = \"stdout:\\n\" + self._container_process.stdout.read().decode()  # type: ignore\n        output += \"\\nstderr:\\n\" + self._container_process.stderr.read().decode()  # type: ignore\n        msg += \"\\n\" + output\n        raise RuntimeError(msg)\n    return await self._runtime.is_alive(timeout=timeout)\n</code></pre>"},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment.start","title":"start  <code>async</code>","text":"<pre><code>start(*, timeout: float | None = None)\n</code></pre> Source code in <code>swerex/deployment/docker.py</code> <pre><code>async def start(\n    self,\n    *,\n    timeout: float | None = None,\n):\n    assert self._container_name is None\n    self._container_name = self._get_container_name()\n    cmds = [\n        \"docker\",\n        \"run\",\n        \"--rm\",\n        \"-p\",\n        f\"{self._port}:8000\",\n        *self._docker_args,\n        \"--name\",\n        self._container_name,\n        self._image_name,\n        REMOTE_EXECUTABLE_NAME,\n    ]\n    self.logger.info(\n        f\"Starting container {self._container_name} with image {self._image_name} serving on port {self._port}\"\n    )\n    self.logger.debug(f\"Command: {' '.join(cmds)}\")\n    self._container_process = subprocess.Popen(cmds, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    self.logger.info(f\"Starting runtime at {self._port}\")\n    self._runtime = RemoteRuntime(port=self._port, timeout=self._runtime_timeout)\n    t0 = time.time()\n    await self._wait_until_alive(timeout=timeout)\n    self.logger.info(f\"Runtime started in {time.time() - t0:.2f}s\")\n</code></pre>"},{"location":"api/deployments/docker/#swerex.deployment.docker.DockerDeployment.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> Source code in <code>swerex/deployment/docker.py</code> <pre><code>async def stop(self):\n    if self._runtime is not None:\n        await self._runtime.close()\n        self._runtime = None\n    if self._container_process is not None:\n        self._container_process.terminate()\n        self._container_process = None\n    self._container_name = None\n</code></pre>"},{"location":"api/deployments/local/","title":"Local","text":""},{"location":"api/deployments/local/#swerex.deployment.local.LocalDeployment","title":"swerex.deployment.local.LocalDeployment","text":"<p>               Bases: <code>AbstractDeployment</code></p> Source code in <code>swerex/deployment/local.py</code> <pre><code>class LocalDeployment(AbstractDeployment):\n    def __init__(\n        self,\n    ):\n        self._runtime = None\n        self._runtime_timeout = 0.15\n\n    async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n        if self._runtime is None:\n            return IsAliveResponse(is_alive=False, message=\"Runtime is None.\")\n        return await self._runtime.is_alive(timeout=timeout)\n\n    async def start(self):\n        self._runtime = Runtime()\n\n    async def stop(self):\n        if self._runtime is not None:\n            await self._runtime.close()\n            self._runtime = None\n\n    @property\n    def runtime(self) -&gt; Runtime:\n        if self._runtime is None:\n            msg = \"Runtime not started\"\n            raise RuntimeError(msg)\n        return self._runtime\n</code></pre>"},{"location":"api/deployments/local/#swerex.deployment.local.LocalDeployment.runtime","title":"runtime  <code>property</code>","text":"<pre><code>runtime: Runtime\n</code></pre>"},{"location":"api/deployments/local/#swerex.deployment.local.LocalDeployment.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>swerex/deployment/local.py</code> <pre><code>def __init__(\n    self,\n):\n    self._runtime = None\n    self._runtime_timeout = 0.15\n</code></pre>"},{"location":"api/deployments/local/#swerex.deployment.local.LocalDeployment.is_alive","title":"is_alive  <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> Source code in <code>swerex/deployment/local.py</code> <pre><code>async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    if self._runtime is None:\n        return IsAliveResponse(is_alive=False, message=\"Runtime is None.\")\n    return await self._runtime.is_alive(timeout=timeout)\n</code></pre>"},{"location":"api/deployments/local/#swerex.deployment.local.LocalDeployment.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> Source code in <code>swerex/deployment/local.py</code> <pre><code>async def start(self):\n    self._runtime = Runtime()\n</code></pre>"},{"location":"api/deployments/local/#swerex.deployment.local.LocalDeployment.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> Source code in <code>swerex/deployment/local.py</code> <pre><code>async def stop(self):\n    if self._runtime is not None:\n        await self._runtime.close()\n        self._runtime = None\n</code></pre>"},{"location":"api/runtimes/abstract/","title":"Abstract","text":""},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime","title":"swerex.runtime.abstract.AbstractRuntime","text":"<p>               Bases: <code>ABC</code></p> <p>This is the main entry point for running stuff.</p> <p>It keeps track of all the sessions (individual repls) that are currently open.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class AbstractRuntime(ABC):\n    \"\"\"This is the main entry point for running stuff.\n\n    It keeps track of all the sessions (individual repls) that are currently open.\n    \"\"\"\n\n    @abstractmethod\n    async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n        \"\"\"Checks if the runtime is alive.\"\"\"\n        pass\n\n    @abstractmethod\n    async def create_session(self, request: CreateSessionRequest) -&gt; CreateSessionResponse:\n        \"\"\"Creates a new session.\"\"\"\n        pass\n\n    @abstractmethod\n    async def run_in_session(self, action: Action) -&gt; Observation:\n        \"\"\"Runs a command in a session.\"\"\"\n        pass\n\n    @abstractmethod\n    async def close_session(self, request: CloseSessionRequest):\n        \"\"\"Closes a shell session.\"\"\"\n        pass\n\n    @abstractmethod\n    async def execute(self, command: Command) -&gt; CommandResponse:\n        \"\"\"Executes a command (independent of any shell session).\"\"\"\n        pass\n\n    @abstractmethod\n    async def read_file(self, request: ReadFileRequest) -&gt; ReadFileResponse:\n        \"\"\"Reads a file\"\"\"\n        pass\n\n    @abstractmethod\n    async def write_file(self, request: WriteFileRequest) -&gt; WriteFileResponse:\n        \"\"\"Writes a file\"\"\"\n        pass\n\n    @abstractmethod\n    async def upload(self, request: UploadRequest) -&gt; UploadResponse:\n        \"\"\"Uploads a file\"\"\"\n        pass\n\n    @abstractmethod\n    async def close(self) -&gt; CloseResponse:\n        \"\"\"Closes the runtime.\"\"\"\n        pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close() -&gt; CloseResponse\n</code></pre> <p>Closes the runtime.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; CloseResponse:\n    \"\"\"Closes the runtime.\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.close_session","title":"close_session  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close_session(request: CloseSessionRequest)\n</code></pre> <p>Closes a shell session.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def close_session(self, request: CloseSessionRequest):\n    \"\"\"Closes a shell session.\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.create_session","title":"create_session  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>create_session(request: CreateSessionRequest) -&gt; CreateSessionResponse\n</code></pre> <p>Creates a new session.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def create_session(self, request: CreateSessionRequest) -&gt; CreateSessionResponse:\n    \"\"\"Creates a new session.\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.execute","title":"execute  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>execute(command: Command) -&gt; CommandResponse\n</code></pre> <p>Executes a command (independent of any shell session).</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def execute(self, command: Command) -&gt; CommandResponse:\n    \"\"\"Executes a command (independent of any shell session).\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.is_alive","title":"is_alive  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> <p>Checks if the runtime is alive.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    \"\"\"Checks if the runtime is alive.\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.read_file","title":"read_file  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>read_file(request: ReadFileRequest) -&gt; ReadFileResponse\n</code></pre> <p>Reads a file</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def read_file(self, request: ReadFileRequest) -&gt; ReadFileResponse:\n    \"\"\"Reads a file\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.run_in_session","title":"run_in_session  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run_in_session(action: Action) -&gt; Observation\n</code></pre> <p>Runs a command in a session.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def run_in_session(self, action: Action) -&gt; Observation:\n    \"\"\"Runs a command in a session.\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.upload","title":"upload  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>upload(request: UploadRequest) -&gt; UploadResponse\n</code></pre> <p>Uploads a file</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def upload(self, request: UploadRequest) -&gt; UploadResponse:\n    \"\"\"Uploads a file\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/abstract/#swerex.runtime.abstract.AbstractRuntime.write_file","title":"write_file  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>write_file(request: WriteFileRequest) -&gt; WriteFileResponse\n</code></pre> <p>Writes a file</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>@abstractmethod\nasync def write_file(self, request: WriteFileRequest) -&gt; WriteFileResponse:\n    \"\"\"Writes a file\"\"\"\n    pass\n</code></pre>"},{"location":"api/runtimes/data/","title":"Data","text":"<p>Classes:</p> Name Description <code>Action</code> <p>An action to run in a session.</p> <code>BashIncorrectSyntaxError</code> <p>Before running a bash command, we check for syntax errors.</p> <code>CloseResponse</code> <code>CloseSessionRequest</code> <code>CloseSessionResponse</code> <code>Command</code> <p>A command to run as a subprocess.</p> <code>CommandResponse</code> <code>CommandTimeoutError</code> <code>CreateSessionRequest</code> <code>CreateSessionResponse</code> <code>IsAliveResponse</code> <p>Response to the is_alive request.</p> <code>NoExitCodeError</code> <code>Observation</code> <code>ReadFileRequest</code> <code>ReadFileResponse</code> <code>SessionDoesNotExistError</code> <code>SessionExistsError</code> <code>SweRexception</code> <code>UninitializedShellError</code> <code>UploadRequest</code> <code>UploadResponse</code> <code>WriteFileRequest</code> <code>WriteFileResponse</code>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action","title":"Action  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An action to run in a session.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class Action(BaseModel):\n    \"\"\"An action to run in a session.\"\"\"\n\n    command: str\n    \"\"\"The command to run.\"\"\"\n\n    session: str = \"default\"\n    \"\"\"The session to run the command in.\"\"\"\n\n    timeout: float | None = None\n    \"\"\"The timeout for the command. None means no timeout.\"\"\"\n\n    is_interactive_command: bool = False\n    \"\"\"For a non-exiting command to an interactive program\n    (e.g., gdb), set this to True.\"\"\"\n\n    is_interactive_quit: bool = False\n    \"\"\"This will disable checking for exit codes, since the command won't terminate.\n    If the command is something like \"quit\" and should terminate the\n    interactive program, set this to False.\n    \"\"\"\n\n    expect: list[str] = []\n    \"\"\"Outputs to expect in addition to the PS1\"\"\"\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: str\n</code></pre> <p>The command to run.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action.expect","title":"expect  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>expect: list[str] = []\n</code></pre> <p>Outputs to expect in addition to the PS1</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action.is_interactive_command","title":"is_interactive_command  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_interactive_command: bool = False\n</code></pre> <p>For a non-exiting command to an interactive program (e.g., gdb), set this to True.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action.is_interactive_quit","title":"is_interactive_quit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_interactive_quit: bool = False\n</code></pre> <p>This will disable checking for exit codes, since the command won't terminate. If the command is something like \"quit\" and should terminate the interactive program, set this to False.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action.session","title":"session  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>session: str = 'default'\n</code></pre> <p>The session to run the command in.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Action.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: float | None = None\n</code></pre> <p>The timeout for the command. None means no timeout.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.BashIncorrectSyntaxError","title":"BashIncorrectSyntaxError","text":"<p>               Bases: <code>SweRexception</code>, <code>RuntimeError</code></p> <p>Before running a bash command, we check for syntax errors. This is the error message for those syntax errors.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class BashIncorrectSyntaxError(SweRexception, RuntimeError):\n    \"\"\"Before running a bash command, we check for syntax errors.\n    This is the error message for those syntax errors.\n    \"\"\"\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CloseResponse","title":"CloseResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class CloseResponse(BaseModel):\n    pass\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CloseSessionRequest","title":"CloseSessionRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class CloseSessionRequest(BaseModel):\n    session: str = \"default\"\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CloseSessionRequest.session","title":"session  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>session: str = 'default'\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CloseSessionResponse","title":"CloseSessionResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class CloseSessionResponse(BaseModel):\n    pass\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Command","title":"Command  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A command to run as a subprocess.</p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class Command(BaseModel):\n    \"\"\"A command to run as a subprocess.\"\"\"\n\n    command: str | list[str]\n    \"\"\"The command to run. Should be a list of strings (recommended because\n    of automatic escaping of spaces etc.) unless you set `shell=True`\n    (i.e., exactly like with `subprocess.run()`).\n    \"\"\"\n\n    timeout: float | None = None\n    \"\"\"The timeout for the command. None means no timeout.\"\"\"\n\n    shell: bool = False\n    \"\"\"Same as the `subprocess.run()` `shell` argument.\"\"\"\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Command.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: str | list[str]\n</code></pre> <p>The command to run. Should be a list of strings (recommended because of automatic escaping of spaces etc.) unless you set <code>shell=True</code> (i.e., exactly like with <code>subprocess.run()</code>).</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Command.shell","title":"shell  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shell: bool = False\n</code></pre> <p>Same as the <code>subprocess.run()</code> <code>shell</code> argument.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Command.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: float | None = None\n</code></pre> <p>The timeout for the command. None means no timeout.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CommandResponse","title":"CommandResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>stdout</code>                 (<code>str</code>)             </li> <li> <code>stderr</code>                 (<code>str</code>)             </li> <li> <code>exit_code</code>                 (<code>int | None</code>)             </li> </ul> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class CommandResponse(BaseModel):\n    stdout: str = \"\"\n    stderr: str = \"\"\n    exit_code: int | None = None\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CommandResponse.exit_code","title":"exit_code  <code>pydantic-field</code>","text":"<pre><code>exit_code: int | None = None\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CommandResponse.stderr","title":"stderr  <code>pydantic-field</code>","text":"<pre><code>stderr: str = ''\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CommandResponse.stdout","title":"stdout  <code>pydantic-field</code>","text":"<pre><code>stdout: str = ''\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CommandTimeoutError","title":"CommandTimeoutError","text":"<p>               Bases: <code>SweRexception</code>, <code>RuntimeError</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class CommandTimeoutError(SweRexception, RuntimeError): ...\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CreateSessionRequest","title":"CreateSessionRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class CreateSessionRequest(BaseModel):\n    session: str = \"default\"\n    \"\"\"The name of the session to create.\"\"\"\n\n    startup_source: list[str] = []\n    \"\"\"Source the following files before running commands.\n    The reason this gets a special treatment is that these files\n    often overwrite PS1, which we need to reset.\n    \"\"\"\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CreateSessionRequest.session","title":"session  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>session: str = 'default'\n</code></pre> <p>The name of the session to create.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CreateSessionRequest.startup_source","title":"startup_source  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>startup_source: list[str] = []\n</code></pre> <p>Source the following files before running commands. The reason this gets a special treatment is that these files often overwrite PS1, which we need to reset.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CreateSessionResponse","title":"CreateSessionResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>output</code>                 (<code>str</code>)             </li> </ul> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class CreateSessionResponse(BaseModel):\n    output: str = \"\"\n    \"\"\"Output from starting the session.\"\"\"\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.CreateSessionResponse.output","title":"output  <code>pydantic-field</code>","text":"<pre><code>output: str = ''\n</code></pre> <p>Output from starting the session.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.IsAliveResponse","title":"IsAliveResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response to the is_alive request.</p> <p>You can test the result with bool().</p> <p>Fields:</p> <ul> <li> <code>is_alive</code>                 (<code>bool</code>)             </li> <li> <code>message</code>                 (<code>str</code>)             </li> </ul> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class IsAliveResponse(BaseModel):\n    \"\"\"Response to the is_alive request.\n\n    You can test the result with bool().\n    \"\"\"\n\n    is_alive: bool\n\n    message: str = \"\"\n    \"\"\"Error message if is_alive is False.\"\"\"\n\n    def __bool__(self) -&gt; bool:\n        return self.is_alive\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.IsAliveResponse.is_alive","title":"is_alive  <code>pydantic-field</code>","text":"<pre><code>is_alive: bool\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.IsAliveResponse.message","title":"message  <code>pydantic-field</code>","text":"<pre><code>message: str = ''\n</code></pre> <p>Error message if is_alive is False.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.NoExitCodeError","title":"NoExitCodeError","text":"<p>               Bases: <code>SweRexception</code>, <code>RuntimeError</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class NoExitCodeError(SweRexception, RuntimeError): ...\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Observation","title":"Observation  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>output</code>                 (<code>str</code>)             </li> <li> <code>exit_code</code>                 (<code>int | None</code>)             </li> <li> <code>failure_reason</code>                 (<code>str</code>)             </li> <li> <code>expect_string</code>                 (<code>str</code>)             </li> </ul> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class Observation(BaseModel):\n    output: str = \"\"\n    exit_code: int | None = None\n    failure_reason: str = \"\"\n\n    expect_string: str = \"\"\n    \"\"\"Which of the expect strings was matched to terminate the command.\n    Empty string if the command timed out etc.\n    \"\"\"\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Observation.exit_code","title":"exit_code  <code>pydantic-field</code>","text":"<pre><code>exit_code: int | None = None\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Observation.expect_string","title":"expect_string  <code>pydantic-field</code>","text":"<pre><code>expect_string: str = ''\n</code></pre> <p>Which of the expect strings was matched to terminate the command. Empty string if the command timed out etc.</p>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Observation.failure_reason","title":"failure_reason  <code>pydantic-field</code>","text":"<pre><code>failure_reason: str = ''\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.Observation.output","title":"output  <code>pydantic-field</code>","text":"<pre><code>output: str = ''\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.ReadFileRequest","title":"ReadFileRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class ReadFileRequest(BaseModel):\n    path: str\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.ReadFileRequest.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.ReadFileResponse","title":"ReadFileResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>content</code>                 (<code>str</code>)             </li> </ul> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class ReadFileResponse(BaseModel):\n    content: str = \"\"\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.ReadFileResponse.content","title":"content  <code>pydantic-field</code>","text":"<pre><code>content: str = ''\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.SessionDoesNotExistError","title":"SessionDoesNotExistError","text":"<p>               Bases: <code>SweRexception</code>, <code>ValueError</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class SessionDoesNotExistError(SweRexception, ValueError): ...\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.SessionExistsError","title":"SessionExistsError","text":"<p>               Bases: <code>SweRexception</code>, <code>ValueError</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class SessionExistsError(SweRexception, ValueError): ...\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.SweRexception","title":"SweRexception","text":"<p>               Bases: <code>RuntimeError</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class SweRexception(RuntimeError): ...\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.UninitializedShellError","title":"UninitializedShellError","text":"<p>               Bases: <code>SweRexception</code>, <code>ValueError</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class UninitializedShellError(SweRexception, ValueError): ...\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.UploadRequest","title":"UploadRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>source_path</code>                 (<code>str</code>)             </li> <li> <code>target_path</code>                 (<code>str</code>)             </li> </ul> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class UploadRequest(BaseModel):\n    source_path: str\n    target_path: str\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.UploadRequest.source_path","title":"source_path  <code>pydantic-field</code>","text":"<pre><code>source_path: str\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.UploadRequest.target_path","title":"target_path  <code>pydantic-field</code>","text":"<pre><code>target_path: str\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.UploadResponse","title":"UploadResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class UploadResponse(BaseModel):\n    pass\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.WriteFileRequest","title":"WriteFileRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class WriteFileRequest(BaseModel):\n    content: str\n    path: str\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.WriteFileRequest.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.WriteFileRequest.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre>"},{"location":"api/runtimes/data/#swerex.runtime.abstract.WriteFileResponse","title":"WriteFileResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>swerex/runtime/abstract.py</code> <pre><code>class WriteFileResponse(BaseModel):\n    pass\n</code></pre>"},{"location":"api/runtimes/local/","title":"Local","text":""},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime","title":"swerex.runtime.local.Runtime","text":"<p>               Bases: <code>AbstractRuntime</code></p> Source code in <code>swerex/runtime/local.py</code> <pre><code>class Runtime(AbstractRuntime):\n    def __init__(self):\n        self.sessions: dict[str, Session] = {}\n\n    async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n        return IsAliveResponse(is_alive=True)\n\n    async def create_session(self, request: CreateSessionRequest) -&gt; CreateSessionResponse:\n        if request.session in self.sessions:\n            msg = f\"session {request.session} already exists\"\n            raise SessionExistsError(msg)\n        shell = Session(request)\n        self.sessions[request.session] = shell\n        return await shell.start()\n\n    async def run_in_session(self, action: Action) -&gt; Observation:\n        if action.session not in self.sessions:\n            msg = f\"session {action.session!r} does not exist\"\n            raise SessionDoesNotExistError(msg)\n        return await self.sessions[action.session].run(action)\n\n    async def close_session(self, request: CloseSessionRequest) -&gt; CloseSessionResponse:\n        if request.session not in self.sessions:\n            msg = f\"session {request.session!r} does not exist\"\n            raise SessionDoesNotExistError(msg)\n        out = await self.sessions[request.session].close()\n        del self.sessions[request.session]\n        return out\n\n    async def execute(self, command: Command) -&gt; CommandResponse:\n        try:\n            result = subprocess.run(command.command, shell=command.shell, timeout=command.timeout, capture_output=True)\n            return CommandResponse(\n                stdout=result.stdout.decode(errors=\"backslashreplace\"),\n                stderr=result.stderr.decode(errors=\"backslashreplace\"),\n                exit_code=result.returncode,\n            )\n        except subprocess.TimeoutExpired as e:\n            msg = f\"Timeout ({command.timeout}s) exceeded while running command\"\n            raise CommandTimeoutError(msg) from e\n\n    async def read_file(self, request: ReadFileRequest) -&gt; ReadFileResponse:\n        content = Path(request.path).read_text()\n        return ReadFileResponse(content=content)\n\n    async def write_file(self, request: WriteFileRequest) -&gt; WriteFileResponse:\n        Path(request.path).parent.mkdir(parents=True, exist_ok=True)\n        Path(request.path).write_text(request.content)\n        return WriteFileResponse()\n\n    async def upload(self, request: UploadRequest) -&gt; UploadResponse:\n        if Path(request.source_path).is_dir():\n            shutil.copytree(request.source_path, request.target_path)\n        else:\n            shutil.copy(request.source_path, request.target_path)\n        return UploadResponse()\n\n    async def close(self) -&gt; CloseResponse:\n        await asyncio.gather(*[self.close_session(CloseSessionRequest(session=s)) for s in self.sessions])\n        return CloseResponse()\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.sessions","title":"sessions  <code>instance-attribute</code>","text":"<pre><code>sessions: dict[str, Session] = {}\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>def __init__(self):\n    self.sessions: dict[str, Session] = {}\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; CloseResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def close(self) -&gt; CloseResponse:\n    await asyncio.gather(*[self.close_session(CloseSessionRequest(session=s)) for s in self.sessions])\n    return CloseResponse()\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.close_session","title":"close_session  <code>async</code>","text":"<pre><code>close_session(request: CloseSessionRequest) -&gt; CloseSessionResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def close_session(self, request: CloseSessionRequest) -&gt; CloseSessionResponse:\n    if request.session not in self.sessions:\n        msg = f\"session {request.session!r} does not exist\"\n        raise SessionDoesNotExistError(msg)\n    out = await self.sessions[request.session].close()\n    del self.sessions[request.session]\n    return out\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.create_session","title":"create_session  <code>async</code>","text":"<pre><code>create_session(request: CreateSessionRequest) -&gt; CreateSessionResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def create_session(self, request: CreateSessionRequest) -&gt; CreateSessionResponse:\n    if request.session in self.sessions:\n        msg = f\"session {request.session} already exists\"\n        raise SessionExistsError(msg)\n    shell = Session(request)\n    self.sessions[request.session] = shell\n    return await shell.start()\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(command: Command) -&gt; CommandResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def execute(self, command: Command) -&gt; CommandResponse:\n    try:\n        result = subprocess.run(command.command, shell=command.shell, timeout=command.timeout, capture_output=True)\n        return CommandResponse(\n            stdout=result.stdout.decode(errors=\"backslashreplace\"),\n            stderr=result.stderr.decode(errors=\"backslashreplace\"),\n            exit_code=result.returncode,\n        )\n    except subprocess.TimeoutExpired as e:\n        msg = f\"Timeout ({command.timeout}s) exceeded while running command\"\n        raise CommandTimeoutError(msg) from e\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.is_alive","title":"is_alive  <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    return IsAliveResponse(is_alive=True)\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.read_file","title":"read_file  <code>async</code>","text":"<pre><code>read_file(request: ReadFileRequest) -&gt; ReadFileResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def read_file(self, request: ReadFileRequest) -&gt; ReadFileResponse:\n    content = Path(request.path).read_text()\n    return ReadFileResponse(content=content)\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.run_in_session","title":"run_in_session  <code>async</code>","text":"<pre><code>run_in_session(action: Action) -&gt; Observation\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def run_in_session(self, action: Action) -&gt; Observation:\n    if action.session not in self.sessions:\n        msg = f\"session {action.session!r} does not exist\"\n        raise SessionDoesNotExistError(msg)\n    return await self.sessions[action.session].run(action)\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.upload","title":"upload  <code>async</code>","text":"<pre><code>upload(request: UploadRequest) -&gt; UploadResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def upload(self, request: UploadRequest) -&gt; UploadResponse:\n    if Path(request.source_path).is_dir():\n        shutil.copytree(request.source_path, request.target_path)\n    else:\n        shutil.copy(request.source_path, request.target_path)\n    return UploadResponse()\n</code></pre>"},{"location":"api/runtimes/local/#swerex.runtime.local.Runtime.write_file","title":"write_file  <code>async</code>","text":"<pre><code>write_file(request: WriteFileRequest) -&gt; WriteFileResponse\n</code></pre> Source code in <code>swerex/runtime/local.py</code> <pre><code>async def write_file(self, request: WriteFileRequest) -&gt; WriteFileResponse:\n    Path(request.path).parent.mkdir(parents=True, exist_ok=True)\n    Path(request.path).write_text(request.content)\n    return WriteFileResponse()\n</code></pre>"},{"location":"api/runtimes/remote/","title":"Remote","text":""},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime","title":"swerex.runtime.remote.RemoteRuntime","text":"<p>               Bases: <code>AbstractRuntime</code></p> Source code in <code>swerex/runtime/remote.py</code> <pre><code>class RemoteRuntime(AbstractRuntime):\n    def __init__(\n        self,\n        *,\n        host: str = \"http://127.0.0.1\",\n        port: int | None = None,\n        token: str | None = None,\n        timeout: float = 0.15,\n    ):\n        \"\"\"A runtime that connects to a remote server.\n\n        Args:\n            host: The host to connect to.\n            port: The port to connect to.\n            token: The API key to use for authentication (if any)\n            timeout: The timeout to use for requests.\n        \"\"\"\n        self.logger = get_logger(\"RR\")\n        if not host.startswith(\"http\"):\n            self.logger.warning(\"Host %s does not start with http, adding http://\", host)\n            host = f\"http://{host}\"\n        self.host = host\n        self.port = port\n        self._token = token\n        self._timeout = timeout\n\n    def _get_timeout(self, timeout: float | None = None) -&gt; float:\n        if timeout is None:\n            return self._timeout\n        return timeout\n\n    @property\n    def _headers(self) -&gt; dict[str, str]:\n        \"\"\"Request headers to use for authentication.\"\"\"\n        if self._token:\n            return {\"X-API-Key\": self._token}\n        return {}\n\n    @property\n    def _api_url(self) -&gt; str:\n        if self.port is None:\n            return self.host\n        return f\"{self.host}:{self.port}\"\n\n    def _handle_transfer_exception(self, exc_transfer: _ExceptionTransfer) -&gt; None:\n        \"\"\"Reraise exceptions that were thrown on the remote.\"\"\"\n        if exc_transfer.traceback:\n            self.logger.debug(\"Traceback: %s\", exc_transfer.traceback)\n        try:\n            module, _, exc_name = exc_transfer.class_path.rpartition(\".\")\n            exception = getattr(sys.modules[module], exc_name)\n        except AttributeError:\n            self.logger.error(f\"Unknown exception class: {exc_transfer.class_path!r}\")\n            raise SweRexception(exc_transfer.message) from None\n        raise exception(exc_transfer.message) from None\n\n    def _handle_response_errors(self, response: requests.Response) -&gt; None:\n        \"\"\"Raise exceptions found in the request response.\"\"\"\n        if response.status_code == 511:\n            exc_transfer = _ExceptionTransfer(**response.json()[\"swerexception\"])\n            self._handle_transfer_exception(exc_transfer)\n        response.raise_for_status()\n\n    async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n        \"\"\"Checks if the runtime is alive.\n\n        Internal server errors are thrown, everything else just has us return False\n        together with the message.\n        \"\"\"\n        try:\n            response = requests.get(\n                f\"{self._api_url}/is_alive\", headers=self._headers, timeout=self._get_timeout(timeout)\n            )\n            if response.status_code == 200:\n                return IsAliveResponse(**response.json())\n            elif response.status_code == 511:\n                exc_transfer = _ExceptionTransfer(**response.json()[\"swerexception\"])\n                self._handle_transfer_exception(exc_transfer)\n            msg = (\n                f\"Status code {response.status_code} from {self._api_url}/is_alive. \"\n                f\"Message: {response.json().get('detail')}\"\n            )\n            return IsAliveResponse(is_alive=False, message=msg)\n        except requests.RequestException:\n            msg = f\"Failed to connect to {self.host}\\n\"\n            msg += traceback.format_exc()\n            self.logger.debug(msg)\n            return IsAliveResponse(is_alive=False, message=msg)\n        except Exception:\n            msg = f\"Failed to connect to {self.host}\\n\"\n            msg += traceback.format_exc()\n            self.logger.debug(msg)\n            return IsAliveResponse(is_alive=False, message=msg)\n\n    async def wait_until_alive(self, *, timeout: float | None = None):\n        return await _wait_until_alive(self.is_alive, timeout=timeout)\n\n    def _request(self, endpoint: str, request: BaseModel | None, output_class: type):\n        \"\"\"Small helper to make requests to the server and handle errors and output.\"\"\"\n        response = requests.post(\n            f\"{self._api_url}/{endpoint}\", json=request.model_dump() if request else None, headers=self._headers\n        )\n        self._handle_response_errors(response)\n        return output_class(**response.json())\n\n    async def create_session(self, request: CreateSessionRequest) -&gt; CreateSessionResponse:\n        return self._request(\"create_session\", request, CreateSessionResponse)\n\n    async def run_in_session(self, action: Action) -&gt; Observation:\n        return self._request(\"run_in_session\", action, Observation)\n\n    async def close_session(self, request: CloseSessionRequest) -&gt; CloseSessionResponse:\n        return self._request(\"close_session\", request, CloseSessionResponse)\n\n    async def execute(self, command: Command) -&gt; CommandResponse:\n        return self._request(\"execute\", command, CommandResponse)\n\n    async def read_file(self, request: ReadFileRequest) -&gt; ReadFileResponse:\n        return self._request(\"read_file\", request, ReadFileResponse)\n\n    async def write_file(self, request: WriteFileRequest) -&gt; WriteFileResponse:\n        return self._request(\"write_file\", request, WriteFileResponse)\n\n    async def upload(self, request: UploadRequest) -&gt; UploadResponse:\n        source = Path(request.source_path)\n        if source.is_dir():\n            with tempfile.TemporaryDirectory() as temp_dir:\n                zip_path = Path(temp_dir) / f\"{source.name}.zip\"\n                shutil.make_archive(str(zip_path.with_suffix(\"\")), \"zip\", source)\n                files = {\"file\": zip_path.open(\"rb\")}\n                data = {\"target_path\": request.target_path, \"unzip\": \"true\"}\n                response = requests.post(f\"{self._api_url}/upload\", files=files, data=data, headers=self._headers)\n                self._handle_response_errors(response)\n                return UploadResponse(**response.json())\n        else:\n            files = {\"file\": source.open(\"rb\")}\n            data = {\"target_path\": request.target_path, \"unzip\": \"false\"}\n            response = requests.post(f\"{self._api_url}/upload\", files=files, data=data, headers=self._headers)\n            self._handle_response_errors(response)\n            return UploadResponse(**response.json())\n\n    async def close(self) -&gt; CloseResponse:\n        return self._request(\"close\", None, CloseResponse)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.host","title":"host  <code>instance-attribute</code>","text":"<pre><code>host = host\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = get_logger('RR')\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port = port\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.__init__","title":"__init__","text":"<pre><code>__init__(*, host: str = 'http://127.0.0.1', port: int | None = None, token: str | None = None, timeout: float = 0.15)\n</code></pre> <p>A runtime that connects to a remote server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host to connect to.</p> <code>'http://127.0.0.1'</code> <code>port</code> <code>int | None</code> <p>The port to connect to.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The API key to use for authentication (if any)</p> <code>None</code> <code>timeout</code> <code>float</code> <p>The timeout to use for requests.</p> <code>0.15</code> Source code in <code>swerex/runtime/remote.py</code> <pre><code>def __init__(\n    self,\n    *,\n    host: str = \"http://127.0.0.1\",\n    port: int | None = None,\n    token: str | None = None,\n    timeout: float = 0.15,\n):\n    \"\"\"A runtime that connects to a remote server.\n\n    Args:\n        host: The host to connect to.\n        port: The port to connect to.\n        token: The API key to use for authentication (if any)\n        timeout: The timeout to use for requests.\n    \"\"\"\n    self.logger = get_logger(\"RR\")\n    if not host.startswith(\"http\"):\n        self.logger.warning(\"Host %s does not start with http, adding http://\", host)\n        host = f\"http://{host}\"\n    self.host = host\n    self.port = port\n    self._token = token\n    self._timeout = timeout\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; CloseResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def close(self) -&gt; CloseResponse:\n    return self._request(\"close\", None, CloseResponse)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.close_session","title":"close_session  <code>async</code>","text":"<pre><code>close_session(request: CloseSessionRequest) -&gt; CloseSessionResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def close_session(self, request: CloseSessionRequest) -&gt; CloseSessionResponse:\n    return self._request(\"close_session\", request, CloseSessionResponse)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.create_session","title":"create_session  <code>async</code>","text":"<pre><code>create_session(request: CreateSessionRequest) -&gt; CreateSessionResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def create_session(self, request: CreateSessionRequest) -&gt; CreateSessionResponse:\n    return self._request(\"create_session\", request, CreateSessionResponse)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(command: Command) -&gt; CommandResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def execute(self, command: Command) -&gt; CommandResponse:\n    return self._request(\"execute\", command, CommandResponse)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.is_alive","title":"is_alive  <code>async</code>","text":"<pre><code>is_alive(*, timeout: float | None = None) -&gt; IsAliveResponse\n</code></pre> <p>Checks if the runtime is alive.</p> <p>Internal server errors are thrown, everything else just has us return False together with the message.</p> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def is_alive(self, *, timeout: float | None = None) -&gt; IsAliveResponse:\n    \"\"\"Checks if the runtime is alive.\n\n    Internal server errors are thrown, everything else just has us return False\n    together with the message.\n    \"\"\"\n    try:\n        response = requests.get(\n            f\"{self._api_url}/is_alive\", headers=self._headers, timeout=self._get_timeout(timeout)\n        )\n        if response.status_code == 200:\n            return IsAliveResponse(**response.json())\n        elif response.status_code == 511:\n            exc_transfer = _ExceptionTransfer(**response.json()[\"swerexception\"])\n            self._handle_transfer_exception(exc_transfer)\n        msg = (\n            f\"Status code {response.status_code} from {self._api_url}/is_alive. \"\n            f\"Message: {response.json().get('detail')}\"\n        )\n        return IsAliveResponse(is_alive=False, message=msg)\n    except requests.RequestException:\n        msg = f\"Failed to connect to {self.host}\\n\"\n        msg += traceback.format_exc()\n        self.logger.debug(msg)\n        return IsAliveResponse(is_alive=False, message=msg)\n    except Exception:\n        msg = f\"Failed to connect to {self.host}\\n\"\n        msg += traceback.format_exc()\n        self.logger.debug(msg)\n        return IsAliveResponse(is_alive=False, message=msg)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.read_file","title":"read_file  <code>async</code>","text":"<pre><code>read_file(request: ReadFileRequest) -&gt; ReadFileResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def read_file(self, request: ReadFileRequest) -&gt; ReadFileResponse:\n    return self._request(\"read_file\", request, ReadFileResponse)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.run_in_session","title":"run_in_session  <code>async</code>","text":"<pre><code>run_in_session(action: Action) -&gt; Observation\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def run_in_session(self, action: Action) -&gt; Observation:\n    return self._request(\"run_in_session\", action, Observation)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.upload","title":"upload  <code>async</code>","text":"<pre><code>upload(request: UploadRequest) -&gt; UploadResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def upload(self, request: UploadRequest) -&gt; UploadResponse:\n    source = Path(request.source_path)\n    if source.is_dir():\n        with tempfile.TemporaryDirectory() as temp_dir:\n            zip_path = Path(temp_dir) / f\"{source.name}.zip\"\n            shutil.make_archive(str(zip_path.with_suffix(\"\")), \"zip\", source)\n            files = {\"file\": zip_path.open(\"rb\")}\n            data = {\"target_path\": request.target_path, \"unzip\": \"true\"}\n            response = requests.post(f\"{self._api_url}/upload\", files=files, data=data, headers=self._headers)\n            self._handle_response_errors(response)\n            return UploadResponse(**response.json())\n    else:\n        files = {\"file\": source.open(\"rb\")}\n        data = {\"target_path\": request.target_path, \"unzip\": \"false\"}\n        response = requests.post(f\"{self._api_url}/upload\", files=files, data=data, headers=self._headers)\n        self._handle_response_errors(response)\n        return UploadResponse(**response.json())\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.wait_until_alive","title":"wait_until_alive  <code>async</code>","text":"<pre><code>wait_until_alive(*, timeout: float | None = None)\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def wait_until_alive(self, *, timeout: float | None = None):\n    return await _wait_until_alive(self.is_alive, timeout=timeout)\n</code></pre>"},{"location":"api/runtimes/remote/#swerex.runtime.remote.RemoteRuntime.write_file","title":"write_file  <code>async</code>","text":"<pre><code>write_file(request: WriteFileRequest) -&gt; WriteFileResponse\n</code></pre> Source code in <code>swerex/runtime/remote.py</code> <pre><code>async def write_file(self, request: WriteFileRequest) -&gt; WriteFileResponse:\n    return self._request(\"write_file\", request, WriteFileResponse)\n</code></pre>"}]}